<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">   
 <meta>
  <!-- Stylesheets -->
  <link href="../web.css" type="text/css" rel="stylesheet"></link>
  <title>VLFeat - Documentation - C API</title>
   
  
  <!-- Scripts-->
  
 </meta>
 
 <!-- Body Start -->
 <body>
  <div id="header">
   <!-- Google CSE Search Box Begins -->
   <form action="http://www.vlfeat.org/search.html" method="get" id="cse-search-box" enctype="application/x-www-form-urlencoded">
    <div>
     <input type="hidden" name="cx" value="003215582122030917471:oq23albfeam"></input>
     <input type="hidden" name="cof" value="FORID:11"></input>
     <input type="hidden" name="ie" value="UTF-8"></input>
     <input type="text" name="q" size="31"></input>
     <input type="submit" name="sa" value="Search"></input>
    </div>
   </form>
   <script src="http://www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en" xml:space="preserve" type="text/javascript"></script>
   <!-- Google CSE Search Box Ends -->
   <h1>VLFeat.org</h1>
  </div>
  <div id="headbanner">
   Documentation - C API
  </div>
  <div id="pagebody">
   <div id="sidebar"> <!-- Navigation Start -->
    <ul>
<li><a href="../index.html">Home</a>
</li>
<li><a href="../download.html">Download</a>
</li>
<li><a href="../doc.html">Documentation</a>
<ul>
<li><a href="../mdoc/mdoc.html">Matlab API</a>
</li>
<li><a href="index.html" class='active' >C API</a>
</li>
<li><a href="../man/man.html">Man pages</a>
</li>
</ul></li>
<li><a href="../overview/tut.html">Tutorials</a>
</li>
</ul>

   </div> <!-- sidebar -->
   <div id="content">
    
    <div class="doxygen">
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>sift.c</h1><a href="sift_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00007"></a>00007 <span class="comment">/* AUTORIGHTS</span>
<a name="l00008"></a>00008 <span class="comment">Copyright (C) 2007-09 Andrea Vedaldi and Brian Fulkerson</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">This file is part of VLFeat, available in the terms of the GNU</span>
<a name="l00011"></a>00011 <span class="comment">General Public License version 2.</span>
<a name="l00012"></a>00012 <span class="comment">*/</span>
<a name="l00013"></a>00013 
<a name="l00676"></a>00676 <span class="preprocessor">#include "<a class="code" href="sift_8h.html" title="Scale Invariant Feature Transform (SIFT).">sift.h</a>"</span>
<a name="l00677"></a>00677 <span class="preprocessor">#include "<a class="code" href="imop_8h.html" title="Image operations.">imop.h</a>"</span>
<a name="l00678"></a>00678 <span class="preprocessor">#include "<a class="code" href="mathop_8h.html" title="Math operations.">mathop.h</a>"</span>
<a name="l00679"></a>00679 
<a name="l00680"></a>00680 <span class="preprocessor">#include &lt;assert.h&gt;</span>
<a name="l00681"></a>00681 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00682"></a>00682 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00683"></a>00683 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00684"></a>00684 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00685"></a>00685 
<a name="l00687"></a>00687 <span class="preprocessor">#define VL_SIFT_BILINEAR_ORIENTATIONS 1</span>
<a name="l00688"></a>00688 <span class="preprocessor"></span>
<a name="l00689"></a>00689 <span class="preprocessor">#define EXPN_SZ  256          </span>
<a name="l00690"></a>00690 <span class="preprocessor">#define EXPN_MAX 25.0         </span>
<a name="l00691"></a><a class="code" href="sift_8c.html#6bfe7ecf9f4b9125e9613e90e4dc8971">00691</a> <span class="preprocessor">double expn_tab [EXPN_SZ+1] ; </span>
<a name="l00693"></a>00693 <span class="preprocessor">#define NBO 8</span>
<a name="l00694"></a>00694 <span class="preprocessor"></span><span class="preprocessor">#define NBP 4</span>
<a name="l00695"></a>00695 <span class="preprocessor"></span>
<a name="l00696"></a>00696 <span class="preprocessor">#define log2(x) (log(x)/VL_LOG_OF_2)</span>
<a name="l00697"></a>00697 <span class="preprocessor"></span>
<a name="l00709"></a>00709 VL_INLINE <span class="keywordtype">double</span>
<a name="l00710"></a><a class="code" href="sift_8c.html#54a28f7f095a58401a7917073f43866f">00710</a> <a class="code" href="sift_8c.html#54a28f7f095a58401a7917073f43866f" title="Fast  approximation.">fast_expn</a> (<span class="keywordtype">double</span> x)
<a name="l00711"></a>00711 {
<a name="l00712"></a>00712   <span class="keywordtype">double</span> a,b,r ;
<a name="l00713"></a>00713   <span class="keywordtype">int</span> i ;
<a name="l00714"></a>00714   <span class="comment">/*assert(0 &lt;= x &amp;&amp; x &lt;= EXPN_MAX) ;*/</span>
<a name="l00715"></a>00715 
<a name="l00716"></a>00716   <span class="keywordflow">if</span> (x &gt; EXPN_MAX) <span class="keywordflow">return</span> 0.0 ;
<a name="l00717"></a>00717 
<a name="l00718"></a>00718   x *= EXPN_SZ / EXPN_MAX ;
<a name="l00719"></a>00719   i = <a class="code" href="mathop_8h.html#48bb7ee0a0b8f26c1ddcc8e9821f36ac" title="Fast (int) floor(x).">vl_floor_d</a> (x) ;
<a name="l00720"></a>00720   r = x - i ;
<a name="l00721"></a>00721   a = <a class="code" href="sift_8c.html#6bfe7ecf9f4b9125e9613e90e4dc8971">expn_tab</a> [i    ] ;
<a name="l00722"></a>00722   b = <a class="code" href="sift_8c.html#6bfe7ecf9f4b9125e9613e90e4dc8971">expn_tab</a> [i + 1] ;
<a name="l00723"></a>00723   <span class="keywordflow">return</span> a + r * (b - a) ;
<a name="l00724"></a>00724 }
<a name="l00725"></a>00725 
<a name="l00731"></a>00731 VL_INLINE <span class="keywordtype">void</span>
<a name="l00732"></a><a class="code" href="sift_8c.html#c0f5ab6b07f3edd4728f6c7439f886f4">00732</a> <a class="code" href="sift_8c.html#c0f5ab6b07f3edd4728f6c7439f886f4" title="Initialize tables for fast_expn.">fast_expn_init</a> ()
<a name="l00733"></a>00733 {
<a name="l00734"></a>00734   <span class="keywordtype">int</span> k  ;
<a name="l00735"></a>00735   <span class="keywordflow">for</span>(k = 0 ; k &lt; EXPN_SZ + 1 ; ++ k) {
<a name="l00736"></a>00736     <a class="code" href="sift_8c.html#6bfe7ecf9f4b9125e9613e90e4dc8971">expn_tab</a> [k] = exp (- (<span class="keywordtype">double</span>) k * (EXPN_MAX / EXPN_SZ)) ;
<a name="l00737"></a>00737   }
<a name="l00738"></a>00738 }
<a name="l00739"></a>00739 
<a name="l00756"></a>00756 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00757"></a>00757 <a class="code" href="sift_8c.html#eb42c89bf4510234d60ba3eef7010c29" title="Copy image, upsample rows and take transpose.">copy_and_upsample_rows</a>
<a name="l00758"></a><a class="code" href="sift_8c.html#eb42c89bf4510234d60ba3eef7010c29">00758</a> (<a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>       *dst,
<a name="l00759"></a>00759  <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> <span class="keyword">const</span> *src, <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height)
<a name="l00760"></a>00760 {
<a name="l00761"></a>00761   <span class="keywordtype">int</span> x, y ;
<a name="l00762"></a>00762   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> a, b ;
<a name="l00763"></a>00763 
<a name="l00764"></a>00764   <span class="keywordflow">for</span>(y = 0 ; y &lt; height ; ++y) {
<a name="l00765"></a>00765     b = a = *src++ ;
<a name="l00766"></a>00766     <span class="keywordflow">for</span>(x = 0 ; x &lt; width - 1 ; ++x) {
<a name="l00767"></a>00767       b = *src++ ;
<a name="l00768"></a>00768       *dst = a ;             dst += height ;
<a name="l00769"></a>00769       *dst = 0.5 * (a + b) ; dst += height ;
<a name="l00770"></a>00770       a = b ;
<a name="l00771"></a>00771     }
<a name="l00772"></a>00772     *dst = b ; dst += height ;
<a name="l00773"></a>00773     *dst = b ; dst += height ;
<a name="l00774"></a>00774     dst += 1 - width * 2 * height ;
<a name="l00775"></a>00775   }
<a name="l00776"></a>00776 }
<a name="l00777"></a>00777 
<a name="l00795"></a>00795 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00796"></a>00796 <a class="code" href="sift_8c.html#457daa5f995f4b946c1a44a45e7702bb" title="Copy and downsample an image.">copy_and_downsample</a>
<a name="l00797"></a><a class="code" href="sift_8c.html#457daa5f995f4b946c1a44a45e7702bb">00797</a> (<a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>       *dst,
<a name="l00798"></a>00798  <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> <span class="keyword">const</span> *src,
<a name="l00799"></a>00799  <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, <span class="keywordtype">int</span> d)
<a name="l00800"></a>00800 {
<a name="l00801"></a>00801   <span class="keywordtype">int</span> x, y ;
<a name="l00802"></a>00802 
<a name="l00803"></a>00803   d = 1 &lt;&lt; d ; <span class="comment">/* d = 2^d */</span>
<a name="l00804"></a>00804   <span class="keywordflow">for</span>(y = 0 ; y &lt; height ; y+=d) {
<a name="l00805"></a>00805     <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> <span class="keyword">const</span> * srcrowp = src + y * width ;
<a name="l00806"></a>00806     <span class="keywordflow">for</span>(x = 0 ; x &lt; width - (d-1) ; x+=d) {
<a name="l00807"></a>00807       *dst++ = *srcrowp ;
<a name="l00808"></a>00808       srcrowp += d ;
<a name="l00809"></a>00809     }
<a name="l00810"></a>00810   }
<a name="l00811"></a>00811 }
<a name="l00812"></a>00812 
<a name="l00832"></a>00832 VL_EXPORT
<a name="l00833"></a>00833 <a class="code" href="struct__VlSiftFilt.html" title="SIFT filter.">VlSiftFilt</a> *
<a name="l00834"></a><a class="code" href="sift_8h.html#7430415e1978727a55a29f203eb38d3e">00834</a> <a class="code" href="sift_8c.html#7430415e1978727a55a29f203eb38d3e" title="Create a new SIFT filter.">vl_sift_new</a> (<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height,
<a name="l00835"></a>00835              <span class="keywordtype">int</span> noctaves, <span class="keywordtype">int</span> nlevels,
<a name="l00836"></a>00836              <span class="keywordtype">int</span> o_min)
<a name="l00837"></a>00837 {
<a name="l00838"></a>00838   <a class="code" href="struct__VlSiftFilt.html" title="SIFT filter.">VlSiftFilt</a> *f = <a class="code" href="generic_8h.html#e28d261fc7cc26f1457b171d842b53ab" title="Call customizable malloc function.">vl_malloc</a> (<span class="keyword">sizeof</span>(<a class="code" href="struct__VlSiftFilt.html" title="SIFT filter.">VlSiftFilt</a>)) ;
<a name="l00839"></a>00839 
<a name="l00840"></a>00840   <span class="keywordtype">int</span> w   = <a class="code" href="generic_8h.html#ee17b425e4672e582e26cf9e103fc0fb" title="Signed left shift operation.">VL_SHIFT_LEFT</a> (width,  -o_min) ;
<a name="l00841"></a>00841   <span class="keywordtype">int</span> h   = <a class="code" href="generic_8h.html#ee17b425e4672e582e26cf9e103fc0fb" title="Signed left shift operation.">VL_SHIFT_LEFT</a> (height, -o_min) ;
<a name="l00842"></a>00842   <span class="keywordtype">int</span> nel = w * h ;
<a name="l00843"></a>00843 
<a name="l00844"></a>00844   <span class="comment">/* negative value O =&gt; calculate max. value */</span>
<a name="l00845"></a>00845   <span class="keywordflow">if</span> (noctaves &lt; 0) {
<a name="l00846"></a>00846     noctaves = <a class="code" href="generic_8h.html#c8a3f4020a3e381daadd4214668dc63c" title="Max operation.">VL_MAX</a> (floor (log2 (<a class="code" href="generic_8h.html#36f2f85796040ca2f71bb34a9f55969f" title="Min operation.">VL_MIN</a>(width, height))) - o_min - 3, 1) ;
<a name="l00847"></a>00847   }
<a name="l00848"></a>00848 
<a name="l00849"></a>00849   f-&gt; width   = width ;
<a name="l00850"></a>00850   f-&gt; height  = height ;
<a name="l00851"></a>00851   f-&gt; O       = noctaves ;
<a name="l00852"></a>00852   f-&gt; S       = nlevels ;
<a name="l00853"></a>00853   f-&gt; o_min   = o_min ;
<a name="l00854"></a>00854   f-&gt; s_min   = -1 ;
<a name="l00855"></a>00855   f-&gt; s_max   = nlevels + 1 ;
<a name="l00856"></a>00856   f-&gt; o_cur   = o_min ;
<a name="l00857"></a>00857 
<a name="l00858"></a>00858   f-&gt; temp    = <a class="code" href="generic_8h.html#e28d261fc7cc26f1457b171d842b53ab" title="Call customizable malloc function.">vl_malloc</a> (<span class="keyword">sizeof</span>(<a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>) * nel    ) ;
<a name="l00859"></a>00859   f-&gt; octave  = <a class="code" href="generic_8h.html#e28d261fc7cc26f1457b171d842b53ab" title="Call customizable malloc function.">vl_malloc</a> (<span class="keyword">sizeof</span>(<a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>) * nel
<a name="l00860"></a>00860                         * (f-&gt;<a class="code" href="struct__VlSiftFilt.html#51a63e5aa77dca58de4c025ff40f77ab">s_max</a> - f-&gt;<a class="code" href="struct__VlSiftFilt.html#3631bdd696add103f8ebfe76750e9228">s_min</a> + 1)  ) ;
<a name="l00861"></a>00861   f-&gt; dog     = <a class="code" href="generic_8h.html#e28d261fc7cc26f1457b171d842b53ab" title="Call customizable malloc function.">vl_malloc</a> (<span class="keyword">sizeof</span>(<a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>) * nel
<a name="l00862"></a>00862                         * (f-&gt;<a class="code" href="struct__VlSiftFilt.html#51a63e5aa77dca58de4c025ff40f77ab">s_max</a> - f-&gt;<a class="code" href="struct__VlSiftFilt.html#3631bdd696add103f8ebfe76750e9228">s_min</a>    )  ) ;
<a name="l00863"></a>00863   f-&gt; grad    = <a class="code" href="generic_8h.html#e28d261fc7cc26f1457b171d842b53ab" title="Call customizable malloc function.">vl_malloc</a> (<span class="keyword">sizeof</span>(<a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>) * nel * 2
<a name="l00864"></a>00864                         * (f-&gt;<a class="code" href="struct__VlSiftFilt.html#51a63e5aa77dca58de4c025ff40f77ab">s_max</a> - f-&gt;<a class="code" href="struct__VlSiftFilt.html#3631bdd696add103f8ebfe76750e9228">s_min</a>    )  ) ;
<a name="l00865"></a>00865 
<a name="l00866"></a>00866   f-&gt; sigman  = 0.5 ;
<a name="l00867"></a>00867   f-&gt; sigmak  = pow (2.0, 1.0 / nlevels) ;
<a name="l00868"></a>00868   f-&gt; sigma0  = 1.6 * f-&gt;<a class="code" href="struct__VlSiftFilt.html#1f91e8c9dbda42d613bf5d771328de7a">sigmak</a> ;
<a name="l00869"></a>00869   f-&gt; dsigma0 = f-&gt;<a class="code" href="struct__VlSiftFilt.html#26c296dd10f53b29b32e40d73294bfc9">sigma0</a> * sqrt (1.0 - 1.0 / (f-&gt;<a class="code" href="struct__VlSiftFilt.html#1f91e8c9dbda42d613bf5d771328de7a">sigmak</a>*f-&gt;<a class="code" href="struct__VlSiftFilt.html#1f91e8c9dbda42d613bf5d771328de7a">sigmak</a>)) ;
<a name="l00870"></a>00870 
<a name="l00871"></a>00871   <span class="comment">/*</span>
<a name="l00872"></a>00872 <span class="comment">  VL_PRINTF ("sigman = %g\n", f-&gt; sigman) ;</span>
<a name="l00873"></a>00873 <span class="comment">  VL_PRINTF ("sigma0 = %g\n", f-&gt; sigma0) ;</span>
<a name="l00874"></a>00874 <span class="comment">  */</span>
<a name="l00875"></a>00875 
<a name="l00876"></a>00876   f-&gt; octave_width  = 0 ;
<a name="l00877"></a>00877   f-&gt; octave_height = 0 ;
<a name="l00878"></a>00878 
<a name="l00879"></a>00879   f-&gt; keys     = 0 ;
<a name="l00880"></a>00880   f-&gt; nkeys    = 0 ;
<a name="l00881"></a>00881   f-&gt; keys_res = 0 ;
<a name="l00882"></a>00882 
<a name="l00883"></a>00883   f-&gt; peak_thresh = 0.0 ;
<a name="l00884"></a>00884   f-&gt; edge_thresh = 10.0 ;
<a name="l00885"></a>00885   f-&gt; norm_thresh = 0.0 ;
<a name="l00886"></a>00886   f-&gt; magnif      = 3.0 ;
<a name="l00887"></a>00887   f-&gt; windowSize  = NBP / 2 ;
<a name="l00888"></a>00888 
<a name="l00889"></a>00889   f-&gt; grad_o  = o_min - 1 ;
<a name="l00890"></a>00890 
<a name="l00891"></a>00891   <span class="comment">/* initialize fast_expn stuff */</span>
<a name="l00892"></a>00892   <a class="code" href="sift_8c.html#c0f5ab6b07f3edd4728f6c7439f886f4" title="Initialize tables for fast_expn.">fast_expn_init</a> () ;
<a name="l00893"></a>00893 
<a name="l00894"></a>00894   <span class="keywordflow">return</span> f ;
<a name="l00895"></a>00895 }
<a name="l00896"></a>00896 
<a name="l00905"></a>00905 VL_EXPORT
<a name="l00906"></a>00906 <span class="keywordtype">void</span>
<a name="l00907"></a><a class="code" href="sift_8h.html#bcf6b47f064329813fa54d80310728cd">00907</a> <a class="code" href="sift_8c.html#bcf6b47f064329813fa54d80310728cd" title="Delete SIFT filter.">vl_sift_delete</a> (<a class="code" href="struct__VlSiftFilt.html" title="SIFT filter.">VlSiftFilt</a>* f)
<a name="l00908"></a>00908 {
<a name="l00909"></a>00909   <span class="keywordflow">if</span>(f) {
<a name="l00910"></a>00910     <span class="keywordflow">if</span>(f-&gt; keys   ) <a class="code" href="generic_8h.html#bb97ff524f46d6c5ce9ca8af9e792cc3" title="Call customizable free function.">vl_free</a> (f-&gt; keys   ) ;
<a name="l00911"></a>00911     <span class="keywordflow">if</span>(f-&gt; grad   ) <a class="code" href="generic_8h.html#bb97ff524f46d6c5ce9ca8af9e792cc3" title="Call customizable free function.">vl_free</a> (f-&gt; grad   ) ;
<a name="l00912"></a>00912     <span class="keywordflow">if</span>(f-&gt; dog    ) <a class="code" href="generic_8h.html#bb97ff524f46d6c5ce9ca8af9e792cc3" title="Call customizable free function.">vl_free</a> (f-&gt; dog    ) ;
<a name="l00913"></a>00913     <span class="keywordflow">if</span>(f-&gt; octave ) <a class="code" href="generic_8h.html#bb97ff524f46d6c5ce9ca8af9e792cc3" title="Call customizable free function.">vl_free</a> (f-&gt; octave ) ;
<a name="l00914"></a>00914     <span class="keywordflow">if</span>(f-&gt; temp   ) <a class="code" href="generic_8h.html#bb97ff524f46d6c5ce9ca8af9e792cc3" title="Call customizable free function.">vl_free</a> (f-&gt; temp   ) ;
<a name="l00915"></a>00915     <a class="code" href="generic_8h.html#bb97ff524f46d6c5ce9ca8af9e792cc3" title="Call customizable free function.">vl_free</a> (f) ;
<a name="l00916"></a>00916   }
<a name="l00917"></a>00917 }
<a name="l00918"></a>00918 
<a name="l00935"></a>00935 VL_EXPORT
<a name="l00936"></a>00936 <span class="keywordtype">int</span>
<a name="l00937"></a><a class="code" href="sift_8h.html#774f028cadf0fc556bfd6170eb0033b9">00937</a> <a class="code" href="sift_8c.html#774f028cadf0fc556bfd6170eb0033b9" title="Start processing a new image.">vl_sift_process_first_octave</a> (<a class="code" href="struct__VlSiftFilt.html" title="SIFT filter.">VlSiftFilt</a> *f, <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> <span class="keyword">const</span> *im)
<a name="l00938"></a>00938 {
<a name="l00939"></a>00939   <span class="keywordtype">int</span> o, s, h, w ;
<a name="l00940"></a>00940   <span class="keywordtype">double</span> sa, sb ;
<a name="l00941"></a>00941   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> *octave ;
<a name="l00942"></a>00942 
<a name="l00943"></a>00943   <span class="comment">/* shortcuts */</span>
<a name="l00944"></a>00944   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> *temp   = f-&gt; temp ;
<a name="l00945"></a>00945   <span class="keywordtype">int</span> width           = f-&gt; width ;
<a name="l00946"></a>00946   <span class="keywordtype">int</span> height          = f-&gt; height ;
<a name="l00947"></a>00947   <span class="keywordtype">int</span> o_min           = f-&gt; o_min ;
<a name="l00948"></a>00948   <span class="keywordtype">int</span> s_min           = f-&gt; s_min ;
<a name="l00949"></a>00949   <span class="keywordtype">int</span> s_max           = f-&gt; s_max ;
<a name="l00950"></a>00950   <span class="keywordtype">double</span> sigma0       = f-&gt; sigma0 ;
<a name="l00951"></a>00951   <span class="keywordtype">double</span> sigmak       = f-&gt; sigmak ;
<a name="l00952"></a>00952   <span class="keywordtype">double</span> sigman       = f-&gt; sigman ;
<a name="l00953"></a>00953   <span class="keywordtype">double</span> dsigma0      = f-&gt; dsigma0 ;
<a name="l00954"></a>00954 
<a name="l00955"></a>00955   <span class="comment">/* restart from the first */</span>
<a name="l00956"></a>00956   f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a> = o_min ;
<a name="l00957"></a>00957   f-&gt;<a class="code" href="struct__VlSiftFilt.html#7e4bab1036ea1bda1dbc2f9afc802706">nkeys</a> = 0 ;
<a name="l00958"></a>00958   w = f-&gt; octave_width  = <a class="code" href="generic_8h.html#ee17b425e4672e582e26cf9e103fc0fb" title="Signed left shift operation.">VL_SHIFT_LEFT</a>(f-&gt;<a class="code" href="struct__VlSiftFilt.html#1906b63621988a3851416bfc87156536">width</a>,  - f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a>) ;
<a name="l00959"></a>00959   h = f-&gt; octave_height = <a class="code" href="generic_8h.html#ee17b425e4672e582e26cf9e103fc0fb" title="Signed left shift operation.">VL_SHIFT_LEFT</a>(f-&gt;<a class="code" href="struct__VlSiftFilt.html#f5c34894fe67875df1c9421584dce8b9">height</a>, - f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a>) ;
<a name="l00960"></a>00960 
<a name="l00961"></a>00961   <span class="comment">/* is there at least one octave? */</span>
<a name="l00962"></a>00962   <span class="keywordflow">if</span> (f-&gt;<a class="code" href="struct__VlSiftFilt.html#e36d5a3c012a53484bbf7ef1a125e69e">O</a> == 0)
<a name="l00963"></a>00963     <span class="keywordflow">return</span> <a class="code" href="generic_8h.html#67cc69e40d7af2aec137b36e53422982">VL_ERR_EOF</a> ;
<a name="l00964"></a>00964 
<a name="l00965"></a>00965   <span class="comment">/* ------------------------------------------------------------------</span>
<a name="l00966"></a>00966 <span class="comment">   *                     Compute the first sublevel of the first octave</span>
<a name="l00967"></a>00967 <span class="comment">   * --------------------------------------------------------------- */</span>
<a name="l00968"></a>00968 
<a name="l00969"></a>00969   <span class="comment">/*</span>
<a name="l00970"></a>00970 <span class="comment">   * If the first octave has negative index, we upscale the image; if</span>
<a name="l00971"></a>00971 <span class="comment">   * the first octave has positive index, we downscale the image; if</span>
<a name="l00972"></a>00972 <span class="comment">   * the first octave has index zero, we just copy the image.</span>
<a name="l00973"></a>00973 <span class="comment">   */</span>
<a name="l00974"></a>00974 
<a name="l00975"></a>00975   octave = <a class="code" href="sift_8h.html#9cc1c77b8fc49875017557096539acb6" title="Get current octave data.">vl_sift_get_octave</a> (f, s_min) ;
<a name="l00976"></a>00976 
<a name="l00977"></a>00977   <span class="keywordflow">if</span> (o_min &lt; 0) {
<a name="l00978"></a>00978     <span class="comment">/* double once */</span>
<a name="l00979"></a>00979     <a class="code" href="sift_8c.html#eb42c89bf4510234d60ba3eef7010c29" title="Copy image, upsample rows and take transpose.">copy_and_upsample_rows</a> (temp,   im,   width,      height) ;
<a name="l00980"></a>00980     <a class="code" href="sift_8c.html#eb42c89bf4510234d60ba3eef7010c29" title="Copy image, upsample rows and take transpose.">copy_and_upsample_rows</a> (octave, temp, height, 2 * width ) ;
<a name="l00981"></a>00981 
<a name="l00982"></a>00982     <span class="comment">/* double more */</span>
<a name="l00983"></a>00983     <span class="keywordflow">for</span>(o = -1 ; o &gt; o_min ; --o) {
<a name="l00984"></a>00984       <a class="code" href="sift_8c.html#eb42c89bf4510234d60ba3eef7010c29" title="Copy image, upsample rows and take transpose.">copy_and_upsample_rows</a> (temp, octave,
<a name="l00985"></a>00985                               width &lt;&lt; -o,      height &lt;&lt; -o ) ;
<a name="l00986"></a>00986       <a class="code" href="sift_8c.html#eb42c89bf4510234d60ba3eef7010c29" title="Copy image, upsample rows and take transpose.">copy_and_upsample_rows</a> (octave, temp,
<a name="l00987"></a>00987                               width &lt;&lt; -o, 2 * (height &lt;&lt; -o)) ;
<a name="l00988"></a>00988     }
<a name="l00989"></a>00989   }
<a name="l00990"></a>00990   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (o_min &gt; 0) {
<a name="l00991"></a>00991     <span class="comment">/* downsample */</span>
<a name="l00992"></a>00992     <a class="code" href="sift_8c.html#457daa5f995f4b946c1a44a45e7702bb" title="Copy and downsample an image.">copy_and_downsample</a> (octave, im, width, height, o_min) ;
<a name="l00993"></a>00993   }
<a name="l00994"></a>00994   <span class="keywordflow">else</span> {
<a name="l00995"></a>00995     <span class="comment">/* direct copy */</span>
<a name="l00996"></a>00996     memcpy(octave, im, <span class="keyword">sizeof</span>(<a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>) * width * height) ;
<a name="l00997"></a>00997   }
<a name="l00998"></a>00998 
<a name="l00999"></a>00999   <span class="comment">/*</span>
<a name="l01000"></a>01000 <span class="comment">   * Here we adjust the smoothing of the first level of the octave.</span>
<a name="l01001"></a>01001 <span class="comment">   * The input image is assumed to have nominal smoothing equal to</span>
<a name="l01002"></a>01002 <span class="comment">   * f-&gt;simgan.</span>
<a name="l01003"></a>01003 <span class="comment">   */</span>
<a name="l01004"></a>01004 
<a name="l01005"></a>01005   sa = sigma0 * pow (sigmak,   s_min) ;
<a name="l01006"></a>01006   sb = sigman * pow (2.0,    - o_min) ;
<a name="l01007"></a>01007 
<a name="l01008"></a>01008   <span class="keywordflow">if</span> (sa &gt; sb) {
<a name="l01009"></a>01009     <span class="keywordtype">double</span> sd = sqrt (sa*sa - sb*sb) ;
<a name="l01010"></a>01010     <a class="code" href="imop_8h.html#1a4f88af24e32dea5e6a84cf3c7590d8" title="Smooth image by Gaussian kernel.">vl_imsmooth_f</a> (octave, temp, octave, w, h, sd) ;
<a name="l01011"></a>01011   }
<a name="l01012"></a>01012 
<a name="l01013"></a>01013   <span class="comment">/* -----------------------------------------------------------------</span>
<a name="l01014"></a>01014 <span class="comment">   *                                          Compute the first octave</span>
<a name="l01015"></a>01015 <span class="comment">   * -------------------------------------------------------------- */</span>
<a name="l01016"></a>01016 
<a name="l01017"></a>01017   <span class="keywordflow">for</span>(s = s_min + 1 ; s &lt;= s_max ; ++s) {
<a name="l01018"></a>01018     <span class="keywordtype">double</span> sd = dsigma0 * pow (sigmak, s) ;
<a name="l01019"></a>01019     <a class="code" href="imop_8h.html#1a4f88af24e32dea5e6a84cf3c7590d8" title="Smooth image by Gaussian kernel.">vl_imsmooth_f</a> (<a class="code" href="sift_8h.html#9cc1c77b8fc49875017557096539acb6" title="Get current octave data.">vl_sift_get_octave</a>(f, s    ), temp,
<a name="l01020"></a>01020                    <a class="code" href="sift_8h.html#9cc1c77b8fc49875017557096539acb6" title="Get current octave data.">vl_sift_get_octave</a>(f, s - 1), w, h, sd) ;
<a name="l01021"></a>01021   }
<a name="l01022"></a>01022 
<a name="l01023"></a>01023   <span class="keywordflow">return</span> <a class="code" href="generic_8h.html#26519a3dd2966d2d46538eb46921abba">VL_ERR_OK</a> ;
<a name="l01024"></a>01024 }
<a name="l01025"></a>01025 
<a name="l01041"></a>01041 VL_EXPORT
<a name="l01042"></a>01042 <span class="keywordtype">int</span>
<a name="l01043"></a><a class="code" href="sift_8h.html#a46dad3788e44ffb6aed2ccb8c445c2d">01043</a> <a class="code" href="sift_8c.html#a46dad3788e44ffb6aed2ccb8c445c2d" title="Process next octave.">vl_sift_process_next_octave</a> (<a class="code" href="struct__VlSiftFilt.html" title="SIFT filter.">VlSiftFilt</a> *f)
<a name="l01044"></a>01044 {
<a name="l01045"></a>01045 
<a name="l01046"></a>01046   <span class="keywordtype">int</span> s, h, w, s_best ;
<a name="l01047"></a>01047   <span class="keywordtype">double</span> sa, sb ;
<a name="l01048"></a>01048   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> *octave, *pt ;
<a name="l01049"></a>01049 
<a name="l01050"></a>01050   <span class="comment">/* shortcuts */</span>
<a name="l01051"></a>01051   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> *temp   = f-&gt; temp ;
<a name="l01052"></a>01052   <span class="keywordtype">int</span> O               = f-&gt; O ;
<a name="l01053"></a>01053   <span class="keywordtype">int</span> S               = f-&gt; S ;
<a name="l01054"></a>01054   <span class="keywordtype">int</span> o_min           = f-&gt; o_min ;
<a name="l01055"></a>01055   <span class="keywordtype">int</span> s_min           = f-&gt; s_min ;
<a name="l01056"></a>01056   <span class="keywordtype">int</span> s_max           = f-&gt; s_max ;
<a name="l01057"></a>01057   <span class="keywordtype">double</span> sigma0       = f-&gt; sigma0 ;
<a name="l01058"></a>01058   <span class="keywordtype">double</span> sigmak       = f-&gt; sigmak ;
<a name="l01059"></a>01059   <span class="keywordtype">double</span> dsigma0      = f-&gt; dsigma0 ;
<a name="l01060"></a>01060 
<a name="l01061"></a>01061   <span class="comment">/* is there another octave ? */</span>
<a name="l01062"></a>01062   <span class="keywordflow">if</span> (f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a> == o_min + O - 1)
<a name="l01063"></a>01063     <span class="keywordflow">return</span> <a class="code" href="generic_8h.html#67cc69e40d7af2aec137b36e53422982">VL_ERR_EOF</a> ;
<a name="l01064"></a>01064 
<a name="l01065"></a>01065   <span class="comment">/* retrieve base */</span>
<a name="l01066"></a>01066   s_best = <a class="code" href="generic_8h.html#36f2f85796040ca2f71bb34a9f55969f" title="Min operation.">VL_MIN</a>(s_min + S, s_max) ;
<a name="l01067"></a>01067   w      = <a class="code" href="sift_8h.html#5d04844056daf18bdd9ad581e4f716eb" title="Get current octave width.">vl_sift_get_octave_width</a>  (f) ;
<a name="l01068"></a>01068   h      = <a class="code" href="sift_8h.html#d5b6d41bea03ce9fef51ba477260cd7e" title="Get current octave height.">vl_sift_get_octave_height</a> (f) ;
<a name="l01069"></a>01069   pt     = <a class="code" href="sift_8h.html#9cc1c77b8fc49875017557096539acb6" title="Get current octave data.">vl_sift_get_octave</a>        (f, s_best) ;
<a name="l01070"></a>01070   octave = <a class="code" href="sift_8h.html#9cc1c77b8fc49875017557096539acb6" title="Get current octave data.">vl_sift_get_octave</a>        (f, s_min) ;
<a name="l01071"></a>01071 
<a name="l01072"></a>01072   <span class="comment">/* next octave */</span>
<a name="l01073"></a>01073   <a class="code" href="sift_8c.html#457daa5f995f4b946c1a44a45e7702bb" title="Copy and downsample an image.">copy_and_downsample</a> (octave, pt, w, h, 1) ;
<a name="l01074"></a>01074 
<a name="l01075"></a>01075   f-&gt; o_cur            += 1 ;
<a name="l01076"></a>01076   f-&gt; nkeys             = 0 ;
<a name="l01077"></a>01077   w = f-&gt; octave_width  = <a class="code" href="generic_8h.html#ee17b425e4672e582e26cf9e103fc0fb" title="Signed left shift operation.">VL_SHIFT_LEFT</a>(f-&gt;<a class="code" href="struct__VlSiftFilt.html#1906b63621988a3851416bfc87156536">width</a>,  - f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a>) ;
<a name="l01078"></a>01078   h = f-&gt; octave_height = <a class="code" href="generic_8h.html#ee17b425e4672e582e26cf9e103fc0fb" title="Signed left shift operation.">VL_SHIFT_LEFT</a>(f-&gt;<a class="code" href="struct__VlSiftFilt.html#f5c34894fe67875df1c9421584dce8b9">height</a>, - f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a>) ;
<a name="l01079"></a>01079 
<a name="l01080"></a>01080   sa = sigma0 * powf (sigmak, s_min     ) ;
<a name="l01081"></a>01081   sb = sigma0 * powf (sigmak, s_best - S) ;
<a name="l01082"></a>01082 
<a name="l01083"></a>01083   <span class="keywordflow">if</span> (sa &gt; sb) {
<a name="l01084"></a>01084     <span class="keywordtype">double</span> sd = sqrt (sa*sa - sb*sb) ;
<a name="l01085"></a>01085     <a class="code" href="imop_8h.html#1a4f88af24e32dea5e6a84cf3c7590d8" title="Smooth image by Gaussian kernel.">vl_imsmooth_f</a> (octave, temp, octave, w, h, sd) ;
<a name="l01086"></a>01086   }
<a name="l01087"></a>01087 
<a name="l01088"></a>01088   <span class="comment">/* ------------------------------------------------------------------</span>
<a name="l01089"></a>01089 <span class="comment">   *                                                        Fill octave</span>
<a name="l01090"></a>01090 <span class="comment">   * --------------------------------------------------------------- */</span>
<a name="l01091"></a>01091 
<a name="l01092"></a>01092   <span class="keywordflow">for</span>(s = s_min + 1 ; s &lt;= s_max ; ++s) {
<a name="l01093"></a>01093     <span class="keywordtype">double</span> sd = dsigma0 * pow (sigmak, s) ;
<a name="l01094"></a>01094     <a class="code" href="imop_8h.html#1a4f88af24e32dea5e6a84cf3c7590d8" title="Smooth image by Gaussian kernel.">vl_imsmooth_f</a> (<a class="code" href="sift_8h.html#9cc1c77b8fc49875017557096539acb6" title="Get current octave data.">vl_sift_get_octave</a>(f, s    ), temp,
<a name="l01095"></a>01095                    <a class="code" href="sift_8h.html#9cc1c77b8fc49875017557096539acb6" title="Get current octave data.">vl_sift_get_octave</a>(f, s - 1), w, h, sd) ;
<a name="l01096"></a>01096   }
<a name="l01097"></a>01097 
<a name="l01098"></a>01098   <span class="keywordflow">return</span> <a class="code" href="generic_8h.html#26519a3dd2966d2d46538eb46921abba">VL_ERR_OK</a> ;
<a name="l01099"></a>01099 }
<a name="l01100"></a>01100 
<a name="l01111"></a>01111 VL_EXPORT
<a name="l01112"></a>01112 <span class="keywordtype">void</span>
<a name="l01113"></a><a class="code" href="sift_8h.html#248f0925ed45fa4632ea30fa9b2229af">01113</a> <a class="code" href="sift_8c.html#248f0925ed45fa4632ea30fa9b2229af" title="Detect keypoints.">vl_sift_detect</a> (<a class="code" href="struct__VlSiftFilt.html" title="SIFT filter.">VlSiftFilt</a> * f)
<a name="l01114"></a>01114 {
<a name="l01115"></a>01115   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>* dog   = f-&gt; dog ;
<a name="l01116"></a>01116   <span class="keywordtype">int</span>          s_min = f-&gt; s_min ;
<a name="l01117"></a>01117   <span class="keywordtype">int</span>          s_max = f-&gt; s_max ;
<a name="l01118"></a>01118   <span class="keywordtype">int</span>          w     = f-&gt; octave_width ;
<a name="l01119"></a>01119   <span class="keywordtype">int</span>          h     = f-&gt; octave_height ;
<a name="l01120"></a>01120   <span class="keywordtype">double</span>       te    = f-&gt; edge_thresh ;
<a name="l01121"></a>01121   <span class="keywordtype">double</span>       tp    = f-&gt; peak_thresh ;
<a name="l01122"></a>01122 
<a name="l01123"></a>01123   <span class="keywordtype">int</span> <span class="keyword">const</span>    xo    = 1 ;      <span class="comment">/* x-stride */</span>
<a name="l01124"></a>01124   <span class="keywordtype">int</span> <span class="keyword">const</span>    yo    = w ;      <span class="comment">/* y-stride */</span>
<a name="l01125"></a>01125   <span class="keywordtype">int</span> <span class="keyword">const</span>    so    = w * h ;  <span class="comment">/* s-stride */</span>
<a name="l01126"></a>01126 
<a name="l01127"></a>01127   <span class="keywordtype">double</span>       xper  = pow (2.0, f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a>) ;
<a name="l01128"></a>01128 
<a name="l01129"></a>01129   <span class="keywordtype">int</span> x, y, s, i, ii, jj ;
<a name="l01130"></a>01130   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> *pt, v ;
<a name="l01131"></a>01131   <a class="code" href="struct__VlSiftKeypoint.html" title="SIFT filter keypoint.">VlSiftKeypoint</a> *k ;
<a name="l01132"></a>01132 
<a name="l01133"></a>01133   <span class="comment">/* clear current list */</span>
<a name="l01134"></a>01134   f-&gt; nkeys = 0 ;
<a name="l01135"></a>01135 
<a name="l01136"></a>01136   <span class="comment">/* compute difference of gaussian (DoG) */</span>
<a name="l01137"></a>01137   pt = f-&gt; dog ;
<a name="l01138"></a>01138   <span class="keywordflow">for</span> (s = s_min ; s &lt;= s_max - 1 ; ++s) {
<a name="l01139"></a>01139     <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>* src_a = <a class="code" href="sift_8h.html#9cc1c77b8fc49875017557096539acb6" title="Get current octave data.">vl_sift_get_octave</a> (f, s    ) ;
<a name="l01140"></a>01140     <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>* src_b = <a class="code" href="sift_8h.html#9cc1c77b8fc49875017557096539acb6" title="Get current octave data.">vl_sift_get_octave</a> (f, s + 1) ;
<a name="l01141"></a>01141     <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>* end_a = src_a + w * h ;
<a name="l01142"></a>01142     <span class="keywordflow">while</span> (src_a != end_a) {
<a name="l01143"></a>01143       *pt++ = *src_b++ - *src_a++ ;
<a name="l01144"></a>01144     }
<a name="l01145"></a>01145   }
<a name="l01146"></a>01146 
<a name="l01147"></a>01147   <span class="comment">/* -----------------------------------------------------------------</span>
<a name="l01148"></a>01148 <span class="comment">   *                                          Find local maxima of DoG</span>
<a name="l01149"></a>01149 <span class="comment">   * -------------------------------------------------------------- */</span>
<a name="l01150"></a>01150 
<a name="l01151"></a>01151   <span class="comment">/* start from dog [1,1,s_min+1] */</span>
<a name="l01152"></a>01152   pt  = dog + xo + yo + so ;
<a name="l01153"></a>01153 
<a name="l01154"></a>01154   <span class="keywordflow">for</span>(s = s_min + 1 ; s &lt;= s_max - 2 ; ++s) {
<a name="l01155"></a>01155     <span class="keywordflow">for</span>(y = 1 ; y &lt; h - 1 ; ++y) {
<a name="l01156"></a>01156       <span class="keywordflow">for</span>(x = 1 ; x &lt; w - 1 ; ++x) {
<a name="l01157"></a>01157         v = *pt ;
<a name="l01158"></a>01158 
<a name="l01159"></a>01159 <span class="preprocessor">#define CHECK_NEIGHBORS(CMP,SGN)                    \</span>
<a name="l01160"></a>01160 <span class="preprocessor">        ( v CMP ## = SGN 0.8 * tp &amp;&amp;                \</span>
<a name="l01161"></a>01161 <span class="preprocessor">          v CMP *(pt + xo) &amp;&amp;                       \</span>
<a name="l01162"></a>01162 <span class="preprocessor">          v CMP *(pt - xo) &amp;&amp;                       \</span>
<a name="l01163"></a>01163 <span class="preprocessor">          v CMP *(pt + so) &amp;&amp;                       \</span>
<a name="l01164"></a>01164 <span class="preprocessor">          v CMP *(pt - so) &amp;&amp;                       \</span>
<a name="l01165"></a>01165 <span class="preprocessor">          v CMP *(pt + yo) &amp;&amp;                       \</span>
<a name="l01166"></a>01166 <span class="preprocessor">          v CMP *(pt - yo) &amp;&amp;                       \</span>
<a name="l01167"></a>01167 <span class="preprocessor">                                                    \</span>
<a name="l01168"></a>01168 <span class="preprocessor">          v CMP *(pt + yo + xo) &amp;&amp;                  \</span>
<a name="l01169"></a>01169 <span class="preprocessor">          v CMP *(pt + yo - xo) &amp;&amp;                  \</span>
<a name="l01170"></a>01170 <span class="preprocessor">          v CMP *(pt - yo + xo) &amp;&amp;                  \</span>
<a name="l01171"></a>01171 <span class="preprocessor">          v CMP *(pt - yo - xo) &amp;&amp;                  \</span>
<a name="l01172"></a>01172 <span class="preprocessor">                                                    \</span>
<a name="l01173"></a>01173 <span class="preprocessor">          v CMP *(pt + xo      + so) &amp;&amp;             \</span>
<a name="l01174"></a>01174 <span class="preprocessor">          v CMP *(pt - xo      + so) &amp;&amp;             \</span>
<a name="l01175"></a>01175 <span class="preprocessor">          v CMP *(pt + yo      + so) &amp;&amp;             \</span>
<a name="l01176"></a>01176 <span class="preprocessor">          v CMP *(pt - yo      + so) &amp;&amp;             \</span>
<a name="l01177"></a>01177 <span class="preprocessor">          v CMP *(pt + yo + xo + so) &amp;&amp;             \</span>
<a name="l01178"></a>01178 <span class="preprocessor">          v CMP *(pt + yo - xo + so) &amp;&amp;             \</span>
<a name="l01179"></a>01179 <span class="preprocessor">          v CMP *(pt - yo + xo + so) &amp;&amp;             \</span>
<a name="l01180"></a>01180 <span class="preprocessor">          v CMP *(pt - yo - xo + so) &amp;&amp;             \</span>
<a name="l01181"></a>01181 <span class="preprocessor">                                                    \</span>
<a name="l01182"></a>01182 <span class="preprocessor">          v CMP *(pt + xo      - so) &amp;&amp;             \</span>
<a name="l01183"></a>01183 <span class="preprocessor">          v CMP *(pt - xo      - so) &amp;&amp;             \</span>
<a name="l01184"></a>01184 <span class="preprocessor">          v CMP *(pt + yo      - so) &amp;&amp;             \</span>
<a name="l01185"></a>01185 <span class="preprocessor">          v CMP *(pt - yo      - so) &amp;&amp;             \</span>
<a name="l01186"></a>01186 <span class="preprocessor">          v CMP *(pt + yo + xo - so) &amp;&amp;             \</span>
<a name="l01187"></a>01187 <span class="preprocessor">          v CMP *(pt + yo - xo - so) &amp;&amp;             \</span>
<a name="l01188"></a>01188 <span class="preprocessor">          v CMP *(pt - yo + xo - so) &amp;&amp;             \</span>
<a name="l01189"></a>01189 <span class="preprocessor">          v CMP *(pt - yo - xo - so) )</span>
<a name="l01190"></a>01190 <span class="preprocessor"></span>
<a name="l01191"></a>01191         <span class="keywordflow">if</span> (CHECK_NEIGHBORS(&gt;,+) ||
<a name="l01192"></a>01192             CHECK_NEIGHBORS(&lt;,-) ) {
<a name="l01193"></a>01193 
<a name="l01194"></a>01194           <span class="comment">/* make room for more keypoints */</span>
<a name="l01195"></a>01195           <span class="keywordflow">if</span> (f-&gt;<a class="code" href="struct__VlSiftFilt.html#7e4bab1036ea1bda1dbc2f9afc802706">nkeys</a> &gt;= f-&gt;<a class="code" href="struct__VlSiftFilt.html#30c797b88b552d10216a6d61d7eeb1de">keys_res</a>) {
<a name="l01196"></a>01196             f-&gt;<a class="code" href="struct__VlSiftFilt.html#30c797b88b552d10216a6d61d7eeb1de">keys_res</a> += 500 ;
<a name="l01197"></a>01197             <span class="keywordflow">if</span> (f-&gt;<a class="code" href="struct__VlSiftFilt.html#c7faf5e26c50f14c32be754b6b5432fc">keys</a>) {
<a name="l01198"></a>01198               f-&gt;<a class="code" href="struct__VlSiftFilt.html#c7faf5e26c50f14c32be754b6b5432fc">keys</a> = <a class="code" href="generic_8h.html#e39d0b3bbe1fc3402febdbab894f2207" title="Call customizable resize function.">vl_realloc</a> (f-&gt;<a class="code" href="struct__VlSiftFilt.html#c7faf5e26c50f14c32be754b6b5432fc">keys</a>,
<a name="l01199"></a>01199                                     f-&gt;<a class="code" href="struct__VlSiftFilt.html#30c797b88b552d10216a6d61d7eeb1de">keys_res</a> *
<a name="l01200"></a>01200                                     <span class="keyword">sizeof</span>(<a class="code" href="struct__VlSiftKeypoint.html" title="SIFT filter keypoint.">VlSiftKeypoint</a>)) ;
<a name="l01201"></a>01201             } <span class="keywordflow">else</span> {
<a name="l01202"></a>01202               f-&gt;<a class="code" href="struct__VlSiftFilt.html#c7faf5e26c50f14c32be754b6b5432fc">keys</a> = <a class="code" href="generic_8h.html#e28d261fc7cc26f1457b171d842b53ab" title="Call customizable malloc function.">vl_malloc</a> (f-&gt;<a class="code" href="struct__VlSiftFilt.html#30c797b88b552d10216a6d61d7eeb1de">keys_res</a> *
<a name="l01203"></a>01203                                    <span class="keyword">sizeof</span>(<a class="code" href="struct__VlSiftKeypoint.html" title="SIFT filter keypoint.">VlSiftKeypoint</a>)) ;
<a name="l01204"></a>01204             }
<a name="l01205"></a>01205           }
<a name="l01206"></a>01206 
<a name="l01207"></a>01207           k = f-&gt;<a class="code" href="struct__VlSiftFilt.html#c7faf5e26c50f14c32be754b6b5432fc">keys</a> + (f-&gt;<a class="code" href="struct__VlSiftFilt.html#7e4bab1036ea1bda1dbc2f9afc802706">nkeys</a> ++) ;
<a name="l01208"></a>01208 
<a name="l01209"></a>01209           k-&gt; ix = x ;
<a name="l01210"></a>01210           k-&gt; iy = y ;
<a name="l01211"></a>01211           k-&gt; is = s ;
<a name="l01212"></a>01212         }
<a name="l01213"></a>01213         pt += 1 ;
<a name="l01214"></a>01214       }
<a name="l01215"></a>01215       pt += 2 ;
<a name="l01216"></a>01216     }
<a name="l01217"></a>01217     pt += 2 * yo ;
<a name="l01218"></a>01218   }
<a name="l01219"></a>01219 
<a name="l01220"></a>01220   <span class="comment">/* -----------------------------------------------------------------</span>
<a name="l01221"></a>01221 <span class="comment">   *                                               Refine local maxima</span>
<a name="l01222"></a>01222 <span class="comment">   * -------------------------------------------------------------- */</span>
<a name="l01223"></a>01223 
<a name="l01224"></a>01224   <span class="comment">/* this pointer is used to write the keypoints back */</span>
<a name="l01225"></a>01225   k = f-&gt;<a class="code" href="struct__VlSiftFilt.html#c7faf5e26c50f14c32be754b6b5432fc">keys</a> ;
<a name="l01226"></a>01226 
<a name="l01227"></a>01227   <span class="keywordflow">for</span> (i = 0 ; i &lt; f-&gt;<a class="code" href="struct__VlSiftFilt.html#7e4bab1036ea1bda1dbc2f9afc802706">nkeys</a> ; ++i) {
<a name="l01228"></a>01228 
<a name="l01229"></a>01229     <span class="keywordtype">int</span> x = f-&gt; keys [i] .ix ;
<a name="l01230"></a>01230     <span class="keywordtype">int</span> y = f-&gt; keys [i] .iy ;
<a name="l01231"></a>01231     <span class="keywordtype">int</span> s = f-&gt; keys [i]. is ;
<a name="l01232"></a>01232 
<a name="l01233"></a>01233     <span class="keywordtype">double</span> Dx=0,Dy=0,Ds=0,Dxx=0,Dyy=0,Dss=0,Dxy=0,Dxs=0,Dys=0 ;
<a name="l01234"></a>01234     <span class="keywordtype">double</span> A [3*3], b [3] ;
<a name="l01235"></a>01235 
<a name="l01236"></a>01236     <span class="keywordtype">int</span> dx = 0 ;
<a name="l01237"></a>01237     <span class="keywordtype">int</span> dy = 0 ;
<a name="l01238"></a>01238 
<a name="l01239"></a>01239     <span class="keywordtype">int</span> iter, i, j ;
<a name="l01240"></a>01240 
<a name="l01241"></a>01241     <span class="keywordflow">for</span> (iter = 0 ; iter &lt; 5 ; ++iter) {
<a name="l01242"></a>01242 
<a name="l01243"></a>01243       x += dx ;
<a name="l01244"></a>01244       y += dy ;
<a name="l01245"></a>01245 
<a name="l01246"></a>01246       pt = dog
<a name="l01247"></a>01247         + xo * x
<a name="l01248"></a>01248         + yo * y
<a name="l01249"></a>01249         + so * (s - s_min) ;
<a name="l01250"></a>01250 
<a name="l01252"></a>01252 <span class="preprocessor">#define at(dx,dy,ds) (*( pt + (dx)*xo + (dy)*yo + (ds)*so))</span>
<a name="l01253"></a>01253 <span class="preprocessor"></span>
<a name="l01255"></a>01255 <span class="preprocessor">#define Aat(i,j)     (A[(i)+(j)*3])</span>
<a name="l01256"></a>01256 <span class="preprocessor"></span>
<a name="l01257"></a>01257       <span class="comment">/* compute the gradient */</span>
<a name="l01258"></a>01258       Dx = 0.5 * (at(+1,0,0) - at(-1,0,0)) ;
<a name="l01259"></a>01259       Dy = 0.5 * (at(0,+1,0) - at(0,-1,0));
<a name="l01260"></a>01260       Ds = 0.5 * (at(0,0,+1) - at(0,0,-1)) ;
<a name="l01261"></a>01261 
<a name="l01262"></a>01262       <span class="comment">/* compute the Hessian */</span>
<a name="l01263"></a>01263       Dxx = (at(+1,0,0) + at(-1,0,0) - 2.0 * at(0,0,0)) ;
<a name="l01264"></a>01264       Dyy = (at(0,+1,0) + at(0,-1,0) - 2.0 * at(0,0,0)) ;
<a name="l01265"></a>01265       Dss = (at(0,0,+1) + at(0,0,-1) - 2.0 * at(0,0,0)) ;
<a name="l01266"></a>01266 
<a name="l01267"></a>01267       Dxy = 0.25 * ( at(+1,+1,0) + at(-1,-1,0) - at(-1,+1,0) - at(+1,-1,0) ) ;
<a name="l01268"></a>01268       Dxs = 0.25 * ( at(+1,0,+1) + at(-1,0,-1) - at(-1,0,+1) - at(+1,0,-1) ) ;
<a name="l01269"></a>01269       Dys = 0.25 * ( at(0,+1,+1) + at(0,-1,-1) - at(0,-1,+1) - at(0,+1,-1) ) ;
<a name="l01270"></a>01270 
<a name="l01271"></a>01271       <span class="comment">/* solve linear system ....................................... */</span>
<a name="l01272"></a>01272       Aat(0,0) = Dxx ;
<a name="l01273"></a>01273       Aat(1,1) = Dyy ;
<a name="l01274"></a>01274       Aat(2,2) = Dss ;
<a name="l01275"></a>01275       Aat(0,1) = Aat(1,0) = Dxy ;
<a name="l01276"></a>01276       Aat(0,2) = Aat(2,0) = Dxs ;
<a name="l01277"></a>01277       Aat(1,2) = Aat(2,1) = Dys ;
<a name="l01278"></a>01278 
<a name="l01279"></a>01279       b[0] = - Dx ;
<a name="l01280"></a>01280       b[1] = - Dy ;
<a name="l01281"></a>01281       b[2] = - Ds ;
<a name="l01282"></a>01282 
<a name="l01283"></a>01283       <span class="comment">/* Gauss elimination */</span>
<a name="l01284"></a>01284       <span class="keywordflow">for</span>(j = 0 ; j &lt; 3 ; ++j) {
<a name="l01285"></a>01285         <span class="keywordtype">double</span> maxa    = 0 ;
<a name="l01286"></a>01286         <span class="keywordtype">double</span> maxabsa = 0 ;
<a name="l01287"></a>01287         <span class="keywordtype">int</span>    maxi    = -1 ;
<a name="l01288"></a>01288         <span class="keywordtype">double</span> tmp ;
<a name="l01289"></a>01289 
<a name="l01290"></a>01290         <span class="comment">/* look for the maximally stable pivot */</span>
<a name="l01291"></a>01291         <span class="keywordflow">for</span> (i = j ; i &lt; 3 ; ++i) {
<a name="l01292"></a>01292           <span class="keywordtype">double</span> a    = Aat (i,j) ;
<a name="l01293"></a>01293           <span class="keywordtype">double</span> absa = <a class="code" href="mathop_8h.html#b54b15a314843c27e7333e2fd05c0eb8" title="Fast abs(x).">vl_abs_d</a> (a) ;
<a name="l01294"></a>01294           <span class="keywordflow">if</span> (absa &gt; maxabsa) {
<a name="l01295"></a>01295             maxa    = a ;
<a name="l01296"></a>01296             maxabsa = absa ;
<a name="l01297"></a>01297             maxi    = i ;
<a name="l01298"></a>01298           }
<a name="l01299"></a>01299         }
<a name="l01300"></a>01300 
<a name="l01301"></a>01301         <span class="comment">/* if singular give up */</span>
<a name="l01302"></a>01302         <span class="keywordflow">if</span> (maxabsa &lt; 1e-10f) {
<a name="l01303"></a>01303           b[0] = 0 ;
<a name="l01304"></a>01304           b[1] = 0 ;
<a name="l01305"></a>01305           b[2] = 0 ;
<a name="l01306"></a>01306           break ;
<a name="l01307"></a>01307         }
<a name="l01308"></a>01308 
<a name="l01309"></a>01309         i = maxi ;
<a name="l01310"></a>01310 
<a name="l01311"></a>01311         <span class="comment">/* swap j-th row with i-th row and normalize j-th row */</span>
<a name="l01312"></a>01312         <span class="keywordflow">for</span>(jj = j ; jj &lt; 3 ; ++jj) {
<a name="l01313"></a>01313           tmp = Aat(i,jj) ; Aat(i,jj) = Aat(j,jj) ; Aat(j,jj) = tmp ;
<a name="l01314"></a>01314           Aat(j,jj) /= maxa ;
<a name="l01315"></a>01315         }
<a name="l01316"></a>01316         tmp = b[j] ; b[j] = b[i] ; b[i] = tmp ;
<a name="l01317"></a>01317         b[j] /= maxa ;
<a name="l01318"></a>01318 
<a name="l01319"></a>01319         <span class="comment">/* elimination */</span>
<a name="l01320"></a>01320         <span class="keywordflow">for</span> (ii = j+1 ; ii &lt; 3 ; ++ii) {
<a name="l01321"></a>01321           <span class="keywordtype">double</span> x = Aat(ii,j) ;
<a name="l01322"></a>01322           <span class="keywordflow">for</span> (jj = j ; jj &lt; 3 ; ++jj) {
<a name="l01323"></a>01323             Aat(ii,jj) -= x * Aat(j,jj) ;
<a name="l01324"></a>01324           }
<a name="l01325"></a>01325           b[ii] -= x * b[j] ;
<a name="l01326"></a>01326         }
<a name="l01327"></a>01327       }
<a name="l01328"></a>01328 
<a name="l01329"></a>01329       <span class="comment">/* backward substitution */</span>
<a name="l01330"></a>01330       <span class="keywordflow">for</span> (i = 2 ; i &gt; 0 ; --i) {
<a name="l01331"></a>01331         <span class="keywordtype">double</span> x = b[i] ;
<a name="l01332"></a>01332         <span class="keywordflow">for</span> (ii = i-1 ; ii &gt;= 0 ; --ii) {
<a name="l01333"></a>01333           b[ii] -= x * Aat(ii,i) ;
<a name="l01334"></a>01334         }
<a name="l01335"></a>01335       }
<a name="l01336"></a>01336 
<a name="l01337"></a>01337       <span class="comment">/* .......................................................... */</span>
<a name="l01338"></a>01338       <span class="comment">/* If the translation of the keypoint is big, move the keypoint</span>
<a name="l01339"></a>01339 <span class="comment">       * and re-iterate the computation. Otherwise we are all set.</span>
<a name="l01340"></a>01340 <span class="comment">       */</span>
<a name="l01341"></a>01341 
<a name="l01342"></a>01342       dx= ((b[0] &gt;  0.6 &amp;&amp; x &lt; w - 2) ?  1 : 0)
<a name="l01343"></a>01343         + ((b[0] &lt; -0.6 &amp;&amp; x &gt; 1    ) ? -1 : 0) ;
<a name="l01344"></a>01344 
<a name="l01345"></a>01345       dy= ((b[1] &gt;  0.6 &amp;&amp; y &lt; h - 2) ?  1 : 0)
<a name="l01346"></a>01346         + ((b[1] &lt; -0.6 &amp;&amp; y &gt; 1    ) ? -1 : 0) ;
<a name="l01347"></a>01347 
<a name="l01348"></a>01348       <span class="keywordflow">if</span> (dx == 0 &amp;&amp; dy == 0) break ;
<a name="l01349"></a>01349     }
<a name="l01350"></a>01350 
<a name="l01351"></a>01351     <span class="comment">/* check threshold and other conditions */</span>
<a name="l01352"></a>01352     {
<a name="l01353"></a>01353       <span class="keywordtype">double</span> val   = at(0,0,0)
<a name="l01354"></a>01354         + 0.5 * (Dx * b[0] + Dy * b[1] + Ds * b[2]) ;
<a name="l01355"></a>01355       <span class="keywordtype">double</span> score = (Dxx+Dyy)*(Dxx+Dyy) / (Dxx*Dyy - Dxy*Dxy) ;
<a name="l01356"></a>01356       <span class="keywordtype">double</span> xn = x + b[0] ;
<a name="l01357"></a>01357       <span class="keywordtype">double</span> yn = y + b[1] ;
<a name="l01358"></a>01358       <span class="keywordtype">double</span> sn = s + b[2] ;
<a name="l01359"></a>01359 
<a name="l01360"></a>01360       <a class="code" href="host_8h.html#d32e7f8ec7333ff33998cf671a3b1412" title="Boolean.">vl_bool</a> good =
<a name="l01361"></a>01361         <a class="code" href="mathop_8h.html#b54b15a314843c27e7333e2fd05c0eb8" title="Fast abs(x).">vl_abs_d</a> (val)  &gt; tp                  &amp;&amp;
<a name="l01362"></a>01362         score           &lt; (te+1)*(te+1)/te    &amp;&amp;
<a name="l01363"></a>01363         score           &gt;= 0                  &amp;&amp;
<a name="l01364"></a>01364         <a class="code" href="mathop_8h.html#b54b15a314843c27e7333e2fd05c0eb8" title="Fast abs(x).">vl_abs_d</a> (b[0]) &lt;  1.5                &amp;&amp;
<a name="l01365"></a>01365         <a class="code" href="mathop_8h.html#b54b15a314843c27e7333e2fd05c0eb8" title="Fast abs(x).">vl_abs_d</a> (b[1]) &lt;  1.5                &amp;&amp;
<a name="l01366"></a>01366         <a class="code" href="mathop_8h.html#b54b15a314843c27e7333e2fd05c0eb8" title="Fast abs(x).">vl_abs_d</a> (b[2]) &lt;  1.5                &amp;&amp;
<a name="l01367"></a>01367         xn              &gt;= 0                  &amp;&amp;
<a name="l01368"></a>01368         xn              &lt;= w - 1              &amp;&amp;
<a name="l01369"></a>01369         yn              &gt;= 0                  &amp;&amp;
<a name="l01370"></a>01370         yn              &lt;= h - 1              &amp;&amp;
<a name="l01371"></a>01371         sn              &gt;= s_min              &amp;&amp;
<a name="l01372"></a>01372         sn              &lt;= s_max ;
<a name="l01373"></a>01373 
<a name="l01374"></a>01374       <span class="keywordflow">if</span> (good) {
<a name="l01375"></a>01375         k-&gt; o     = f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a> ;
<a name="l01376"></a>01376         k-&gt; ix    = x ;
<a name="l01377"></a>01377         k-&gt; iy    = y ;
<a name="l01378"></a>01378         k-&gt; is    = s ;
<a name="l01379"></a>01379         k-&gt; s     = sn ;
<a name="l01380"></a>01380         k-&gt; x     = xn * xper ;
<a name="l01381"></a>01381         k-&gt; y     = yn * xper ;
<a name="l01382"></a>01382         k-&gt; sigma = f-&gt;<a class="code" href="struct__VlSiftFilt.html#26c296dd10f53b29b32e40d73294bfc9">sigma0</a> * pow (2.0, sn/f-&gt;<a class="code" href="struct__VlSiftFilt.html#8531fa640678ec497e74d8fe4bfd18bd">S</a>) * xper ;
<a name="l01383"></a>01383         ++ k ;
<a name="l01384"></a>01384       }
<a name="l01385"></a>01385 
<a name="l01386"></a>01386     } <span class="comment">/* done checking */</span>
<a name="l01387"></a>01387   } <span class="comment">/* next keypoint to refine */</span>
<a name="l01388"></a>01388 
<a name="l01389"></a>01389   <span class="comment">/* update keypoint count */</span>
<a name="l01390"></a>01390   f-&gt; nkeys = k - f-&gt;<a class="code" href="struct__VlSiftFilt.html#c7faf5e26c50f14c32be754b6b5432fc">keys</a> ;
<a name="l01391"></a>01391 }
<a name="l01392"></a>01392 
<a name="l01393"></a>01393 
<a name="l01406"></a>01406 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01407"></a><a class="code" href="sift_8c.html#ce1fba61b0cc6ad7b1b0f9a07eabdf87">01407</a> <a class="code" href="sift_8c.html#ce1fba61b0cc6ad7b1b0f9a07eabdf87" title="Update gradients to current GSS octave.">update_gradient</a> (<a class="code" href="struct__VlSiftFilt.html" title="SIFT filter.">VlSiftFilt</a> *f)
<a name="l01408"></a>01408 {
<a name="l01409"></a>01409   <span class="keywordtype">int</span>       s_min = f-&gt;<a class="code" href="struct__VlSiftFilt.html#3631bdd696add103f8ebfe76750e9228">s_min</a> ;
<a name="l01410"></a>01410   <span class="keywordtype">int</span>       s_max = f-&gt;<a class="code" href="struct__VlSiftFilt.html#51a63e5aa77dca58de4c025ff40f77ab">s_max</a> ;
<a name="l01411"></a>01411   <span class="keywordtype">int</span>       w     = <a class="code" href="sift_8h.html#5d04844056daf18bdd9ad581e4f716eb" title="Get current octave width.">vl_sift_get_octave_width</a>  (f) ;
<a name="l01412"></a>01412   <span class="keywordtype">int</span>       h     = <a class="code" href="sift_8h.html#d5b6d41bea03ce9fef51ba477260cd7e" title="Get current octave height.">vl_sift_get_octave_height</a> (f) ;
<a name="l01413"></a>01413   <span class="keywordtype">int</span> <span class="keyword">const</span> xo    = 1 ;
<a name="l01414"></a>01414   <span class="keywordtype">int</span> <span class="keyword">const</span> yo    = w ;
<a name="l01415"></a>01415   <span class="keywordtype">int</span> <span class="keyword">const</span> so    = h * w ;
<a name="l01416"></a>01416   <span class="keywordtype">int</span> y, s ;
<a name="l01417"></a>01417 
<a name="l01418"></a>01418   <span class="keywordflow">if</span> (f-&gt;<a class="code" href="struct__VlSiftFilt.html#dc7ee960ea6e3cebb08edeb0d33becad">grad_o</a> == f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a>) return ;
<a name="l01419"></a>01419 
<a name="l01420"></a>01420   <span class="keywordflow">for</span> (s  = s_min + 1 ;
<a name="l01421"></a>01421        s &lt;= s_max - 2 ; ++ s) {
<a name="l01422"></a>01422 
<a name="l01423"></a>01423     <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> *src, *end, *grad, gx, gy ;
<a name="l01424"></a>01424 
<a name="l01425"></a>01425 <span class="preprocessor">#define SAVE_BACK                                                       \</span>
<a name="l01426"></a>01426 <span class="preprocessor">    *grad++ = vl_fast_sqrt_f (gx*gx + gy*gy) ;                          \</span>
<a name="l01427"></a>01427 <span class="preprocessor">    *grad++ = vl_mod_2pi_f   (vl_fast_atan2_f (gy, gx) + 2*VL_PI) ;     \</span>
<a name="l01428"></a>01428 <span class="preprocessor">    ++src ;                                                             \</span>
<a name="l01429"></a>01429 <span class="preprocessor"></span>
<a name="l01430"></a>01430 <span class="preprocessor"></span>    src  = <a class="code" href="sift_8h.html#9cc1c77b8fc49875017557096539acb6" title="Get current octave data.">vl_sift_get_octave</a> (f,s) ;
<a name="l01431"></a>01431     grad = f-&gt;<a class="code" href="struct__VlSiftFilt.html#3dc6a5613163485ab9f0607b662af868">grad</a> + 2 * so * (s - s_min -1) ;
<a name="l01432"></a>01432 
<a name="l01433"></a>01433     <span class="comment">/* first pixel of the first row */</span>
<a name="l01434"></a>01434     gx = src[+xo] - src[0] ;
<a name="l01435"></a>01435     gy = src[+yo] - src[0] ;
<a name="l01436"></a>01436     SAVE_BACK ;
<a name="l01437"></a>01437 
<a name="l01438"></a>01438     <span class="comment">/* middle pixels of the  first row */</span>
<a name="l01439"></a>01439     end = (src - 1) + w - 1 ;
<a name="l01440"></a>01440     <span class="keywordflow">while</span> (src &lt; end) {
<a name="l01441"></a>01441       gx = 0.5 * (src[+xo] - src[-xo]) ;
<a name="l01442"></a>01442       gy =        src[+yo] - src[0] ;
<a name="l01443"></a>01443       SAVE_BACK ;
<a name="l01444"></a>01444     }
<a name="l01445"></a>01445 
<a name="l01446"></a>01446     <span class="comment">/* last pixel of the first row */</span>
<a name="l01447"></a>01447     gx = src[0]   - src[-xo] ;
<a name="l01448"></a>01448     gy = src[+yo] - src[0] ;
<a name="l01449"></a>01449     SAVE_BACK ;
<a name="l01450"></a>01450 
<a name="l01451"></a>01451     <span class="keywordflow">for</span> (y = 1 ; y &lt; h -1 ; ++y) {
<a name="l01452"></a>01452 
<a name="l01453"></a>01453       <span class="comment">/* first pixel of the middle rows */</span>
<a name="l01454"></a>01454       gx =        src[+xo] - src[0] ;
<a name="l01455"></a>01455       gy = 0.5 * (src[+yo] - src[-yo]) ;
<a name="l01456"></a>01456       SAVE_BACK ;
<a name="l01457"></a>01457 
<a name="l01458"></a>01458       <span class="comment">/* middle pixels of the middle rows */</span>
<a name="l01459"></a>01459       end = (src - 1) + w - 1 ;
<a name="l01460"></a>01460       <span class="keywordflow">while</span> (src &lt; end) {
<a name="l01461"></a>01461         gx = 0.5 * (src[+xo] - src[-xo]) ;
<a name="l01462"></a>01462         gy = 0.5 * (src[+yo] - src[-yo]) ;
<a name="l01463"></a>01463         SAVE_BACK ;
<a name="l01464"></a>01464       }
<a name="l01465"></a>01465 
<a name="l01466"></a>01466       <span class="comment">/* last pixel of the middle row */</span>
<a name="l01467"></a>01467       gx =        src[0]   - src[-xo] ;
<a name="l01468"></a>01468       gy = 0.5 * (src[+yo] - src[-yo]) ;
<a name="l01469"></a>01469       SAVE_BACK ;
<a name="l01470"></a>01470     }
<a name="l01471"></a>01471 
<a name="l01472"></a>01472     <span class="comment">/* first pixel of the last row */</span>
<a name="l01473"></a>01473     gx = src[+xo] - src[0] ;
<a name="l01474"></a>01474     gy = src[  0] - src[-yo] ;
<a name="l01475"></a>01475     SAVE_BACK ;
<a name="l01476"></a>01476 
<a name="l01477"></a>01477     <span class="comment">/* middle pixels of the last row */</span>
<a name="l01478"></a>01478     end = (src - 1) + w - 1 ;
<a name="l01479"></a>01479     <span class="keywordflow">while</span> (src &lt; end) {
<a name="l01480"></a>01480       gx = 0.5 * (src[+xo] - src[-xo]) ;
<a name="l01481"></a>01481       gy =        src[0]   - src[-yo] ;
<a name="l01482"></a>01482       SAVE_BACK ;
<a name="l01483"></a>01483     }
<a name="l01484"></a>01484 
<a name="l01485"></a>01485     <span class="comment">/* last pixel of the last row */</span>
<a name="l01486"></a>01486     gx = src[0]   - src[-xo] ;
<a name="l01487"></a>01487     gy = src[0]   - src[-yo] ;
<a name="l01488"></a>01488     SAVE_BACK ;
<a name="l01489"></a>01489   }
<a name="l01490"></a>01490   f-&gt;<a class="code" href="struct__VlSiftFilt.html#dc7ee960ea6e3cebb08edeb0d33becad">grad_o</a> = f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a> ;
<a name="l01491"></a>01491 }
<a name="l01492"></a>01492 
<a name="l01517"></a>01517 VL_EXPORT
<a name="l01518"></a>01518 <span class="keywordtype">int</span>
<a name="l01519"></a><a class="code" href="sift_8h.html#b38b0a5d98e491762041e7378355b7b6">01519</a> <a class="code" href="sift_8c.html#b38b0a5d98e491762041e7378355b7b6" title="Calculate the keypoint orientation(s).">vl_sift_calc_keypoint_orientations</a> (<a class="code" href="struct__VlSiftFilt.html" title="SIFT filter.">VlSiftFilt</a> *f,
<a name="l01520"></a>01520                                     <span class="keywordtype">double</span> angles [4],
<a name="l01521"></a>01521                                     <a class="code" href="struct__VlSiftKeypoint.html" title="SIFT filter keypoint.">VlSiftKeypoint</a> <span class="keyword">const</span> *k)
<a name="l01522"></a>01522 {
<a name="l01523"></a>01523   <span class="keywordtype">double</span> <span class="keyword">const</span> winf   = 1.5 ;
<a name="l01524"></a>01524   <span class="keywordtype">double</span>       xper   = pow (2.0, f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a>) ;
<a name="l01525"></a>01525 
<a name="l01526"></a>01526   <span class="keywordtype">int</span>          w      = f-&gt; octave_width ;
<a name="l01527"></a>01527   <span class="keywordtype">int</span>          h      = f-&gt; octave_height ;
<a name="l01528"></a>01528   <span class="keywordtype">int</span> <span class="keyword">const</span>    xo     = 2 ;         <span class="comment">/* x-stride */</span>
<a name="l01529"></a>01529   <span class="keywordtype">int</span> <span class="keyword">const</span>    yo     = 2 * w ;     <span class="comment">/* y-stride */</span>
<a name="l01530"></a>01530   <span class="keywordtype">int</span> <span class="keyword">const</span>    so     = 2 * w * h ; <span class="comment">/* s-stride */</span>
<a name="l01531"></a>01531   <span class="keywordtype">double</span>       x      = k-&gt; x     / xper ;
<a name="l01532"></a>01532   <span class="keywordtype">double</span>       y      = k-&gt; y     / xper ;
<a name="l01533"></a>01533   <span class="keywordtype">double</span>       sigma  = k-&gt; sigma / xper ;
<a name="l01534"></a>01534 
<a name="l01535"></a>01535   <span class="keywordtype">int</span>          xi     = (int) (x + 0.5) ;
<a name="l01536"></a>01536   <span class="keywordtype">int</span>          yi     = (int) (y + 0.5) ;
<a name="l01537"></a>01537   <span class="keywordtype">int</span>          si     = k-&gt; is ;
<a name="l01538"></a>01538 
<a name="l01539"></a>01539   <span class="keywordtype">double</span> <span class="keyword">const</span> sigmaw = winf * sigma ;
<a name="l01540"></a>01540   <span class="keywordtype">int</span>          W      = <a class="code" href="generic_8h.html#c8a3f4020a3e381daadd4214668dc63c" title="Max operation.">VL_MAX</a>(floor (3.0 * sigmaw), 1) ;
<a name="l01541"></a>01541 
<a name="l01542"></a>01542   <span class="keywordtype">int</span>          nangles= 0 ;
<a name="l01543"></a>01543 
<a name="l01544"></a>01544   <span class="keyword">enum</span> {nbins = 36} ;
<a name="l01545"></a>01545 
<a name="l01546"></a>01546   <span class="keywordtype">double</span> hist [nbins], maxh ;
<a name="l01547"></a>01547   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> <span class="keyword">const</span> * pt ;
<a name="l01548"></a>01548   <span class="keywordtype">int</span> xs, ys, iter, i ;
<a name="l01549"></a>01549 
<a name="l01550"></a>01550   <span class="comment">/* skip if the keypoint octave is not current */</span>
<a name="l01551"></a>01551   <span class="keywordflow">if</span>(k-&gt;<a class="code" href="struct__VlSiftKeypoint.html#c50bd6df4c02dc9a8328182138bdfd96">o</a> != f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a>)
<a name="l01552"></a>01552     <span class="keywordflow">return</span> 0 ;
<a name="l01553"></a>01553 
<a name="l01554"></a>01554   <span class="comment">/* skip the keypoint if it is out of bounds */</span>
<a name="l01555"></a>01555   <span class="keywordflow">if</span>(xi &lt; 0            ||
<a name="l01556"></a>01556      xi &gt; w - 1        ||
<a name="l01557"></a>01557      yi &lt; 0            ||
<a name="l01558"></a>01558      yi &gt; h - 1        ||
<a name="l01559"></a>01559      si &lt; f-&gt;s_min + 1 ||
<a name="l01560"></a>01560      si &gt; f-&gt;<a class="code" href="struct__VlSiftFilt.html#51a63e5aa77dca58de4c025ff40f77ab">s_max</a> - 2  ) {
<a name="l01561"></a>01561     <span class="keywordflow">return</span> 0 ;
<a name="l01562"></a>01562   }
<a name="l01563"></a>01563 
<a name="l01564"></a>01564   <span class="comment">/* make gradient up to date */</span>
<a name="l01565"></a>01565   <a class="code" href="sift_8c.html#ce1fba61b0cc6ad7b1b0f9a07eabdf87" title="Update gradients to current GSS octave.">update_gradient</a> (f) ;
<a name="l01566"></a>01566 
<a name="l01567"></a>01567   <span class="comment">/* clear histogram */</span>
<a name="l01568"></a>01568   memset (hist, 0, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) * nbins) ;
<a name="l01569"></a>01569 
<a name="l01570"></a>01570   <span class="comment">/* compute orientation histogram */</span>
<a name="l01571"></a>01571   pt = f-&gt; grad + xo*xi + yo*yi + so*(si - f-&gt;<a class="code" href="struct__VlSiftFilt.html#3631bdd696add103f8ebfe76750e9228">s_min</a> - 1) ;
<a name="l01572"></a>01572 
<a name="l01573"></a>01573 <span class="preprocessor">#undef  at</span>
<a name="l01574"></a>01574 <span class="preprocessor"></span><span class="preprocessor">#define at(dx,dy) (*(pt + xo * (dx) + yo * (dy)))</span>
<a name="l01575"></a>01575 <span class="preprocessor"></span>
<a name="l01576"></a>01576   <span class="keywordflow">for</span>(ys  =  <a class="code" href="generic_8h.html#c8a3f4020a3e381daadd4214668dc63c" title="Max operation.">VL_MAX</a> (- W,       - yi) ;
<a name="l01577"></a>01577       ys &lt;=  <a class="code" href="generic_8h.html#36f2f85796040ca2f71bb34a9f55969f" title="Min operation.">VL_MIN</a> (+ W, h - 1 - yi) ; ++ys) {
<a name="l01578"></a>01578 
<a name="l01579"></a>01579     <span class="keywordflow">for</span>(xs  = <a class="code" href="generic_8h.html#c8a3f4020a3e381daadd4214668dc63c" title="Max operation.">VL_MAX</a> (- W,       - xi) ;
<a name="l01580"></a>01580         xs &lt;= <a class="code" href="generic_8h.html#36f2f85796040ca2f71bb34a9f55969f" title="Min operation.">VL_MIN</a> (+ W, w - 1 - xi) ; ++xs) {
<a name="l01581"></a>01581 
<a name="l01582"></a>01582 
<a name="l01583"></a>01583       <span class="keywordtype">double</span> dx = (double)(xi + xs) - x;
<a name="l01584"></a>01584       <span class="keywordtype">double</span> dy = (double)(yi + ys) - y;
<a name="l01585"></a>01585       <span class="keywordtype">double</span> r2 = dx*dx + dy*dy ;
<a name="l01586"></a>01586       <span class="keywordtype">double</span> wgt, mod, ang, fbin ;
<a name="l01587"></a>01587 
<a name="l01588"></a>01588       <span class="comment">/* limit to a circular window */</span>
<a name="l01589"></a>01589       <span class="keywordflow">if</span> (r2 &gt;= W*W + 0.6) continue ;
<a name="l01590"></a>01590 
<a name="l01591"></a>01591       wgt  = <a class="code" href="sift_8c.html#54a28f7f095a58401a7917073f43866f" title="Fast  approximation.">fast_expn</a> (r2 / (2*sigmaw*sigmaw)) ;
<a name="l01592"></a>01592       mod  = *(pt + xs*xo + ys*yo    ) ;
<a name="l01593"></a>01593       ang  = *(pt + xs*xo + ys*yo + 1) ;
<a name="l01594"></a>01594       fbin = nbins * ang / (2 * <a class="code" href="mathop_8h.html#19d43a5e0c355df553ebe825208a4cc1" title="Pi (math constant).">VL_PI</a>) ;
<a name="l01595"></a>01595 
<a name="l01596"></a>01596 <span class="preprocessor">#if defined(VL_SIFT_BILINEAR_ORIENTATIONS)</span>
<a name="l01597"></a>01597 <span class="preprocessor"></span>      {
<a name="l01598"></a>01598         <span class="keywordtype">int</span>    bin  = <a class="code" href="mathop_8h.html#48bb7ee0a0b8f26c1ddcc8e9821f36ac" title="Fast (int) floor(x).">vl_floor_d</a> (fbin - 0.5) ;
<a name="l01599"></a>01599         <span class="keywordtype">double</span> rbin = fbin - bin - 0.5 ;
<a name="l01600"></a>01600         hist [(bin + nbins) % nbins] += (1 - rbin) * mod * wgt ;
<a name="l01601"></a>01601         hist [(bin + 1    ) % nbins] += (    rbin) * mod * wgt ;
<a name="l01602"></a>01602       }
<a name="l01603"></a>01603 <span class="preprocessor">#else</span>
<a name="l01604"></a>01604 <span class="preprocessor"></span>      {
<a name="l01605"></a>01605         <span class="keywordtype">int</span>    bin  = <a class="code" href="mathop_8h.html#48bb7ee0a0b8f26c1ddcc8e9821f36ac" title="Fast (int) floor(x).">vl_floor_d</a> (fbin) ;
<a name="l01606"></a>01606         bin = <a class="code" href="mathop_8h.html#48bb7ee0a0b8f26c1ddcc8e9821f36ac" title="Fast (int) floor(x).">vl_floor_d</a> (nbins * ang / (2*<a class="code" href="mathop_8h.html#19d43a5e0c355df553ebe825208a4cc1" title="Pi (math constant).">VL_PI</a>)) ;
<a name="l01607"></a>01607         hist [(bin) % nbins] += mod * wgt ;
<a name="l01608"></a>01608       }
<a name="l01609"></a>01609 <span class="preprocessor">#endif</span>
<a name="l01610"></a>01610 <span class="preprocessor"></span>
<a name="l01611"></a>01611     } <span class="comment">/* for xs */</span>
<a name="l01612"></a>01612   } <span class="comment">/* for ys */</span>
<a name="l01613"></a>01613 
<a name="l01614"></a>01614   <span class="comment">/* smooth histogram */</span>
<a name="l01615"></a>01615   <span class="keywordflow">for</span> (iter = 0; iter &lt; 6; iter ++) {
<a name="l01616"></a>01616     <span class="keywordtype">double</span> prev  = hist [nbins - 1] ;
<a name="l01617"></a>01617     <span class="keywordtype">double</span> first = hist [0] ;
<a name="l01618"></a>01618     <span class="keywordtype">int</span> i ;
<a name="l01619"></a>01619     <span class="keywordflow">for</span> (i = 0; i &lt; nbins - 1; i++) {
<a name="l01620"></a>01620       <span class="keywordtype">double</span> newh = (prev + hist[i] + hist[(i+1) % nbins]) / 3.0;
<a name="l01621"></a>01621       prev = hist[i] ;
<a name="l01622"></a>01622       hist[i] = newh ;
<a name="l01623"></a>01623     }
<a name="l01624"></a>01624     hist[i] = (prev + hist[i] + first) / 3.0 ;
<a name="l01625"></a>01625   }
<a name="l01626"></a>01626 
<a name="l01627"></a>01627   <span class="comment">/* find the histogram maximum */</span>
<a name="l01628"></a>01628   maxh = 0 ;
<a name="l01629"></a>01629   <span class="keywordflow">for</span> (i = 0 ; i &lt; nbins ; ++i)
<a name="l01630"></a>01630     maxh = <a class="code" href="generic_8h.html#c8a3f4020a3e381daadd4214668dc63c" title="Max operation.">VL_MAX</a> (maxh, hist [i]) ;
<a name="l01631"></a>01631 
<a name="l01632"></a>01632   <span class="comment">/* find peaks within 80% from max */</span>
<a name="l01633"></a>01633   nangles = 0 ;
<a name="l01634"></a>01634   <span class="keywordflow">for</span>(i = 0 ; i &lt; nbins ; ++i) {
<a name="l01635"></a>01635     <span class="keywordtype">double</span> h0 = hist [i] ;
<a name="l01636"></a>01636     <span class="keywordtype">double</span> hm = hist [(i - 1 + nbins) % nbins] ;
<a name="l01637"></a>01637     <span class="keywordtype">double</span> hp = hist [(i + 1 + nbins) % nbins] ;
<a name="l01638"></a>01638 
<a name="l01639"></a>01639     <span class="comment">/* is this a peak? */</span>
<a name="l01640"></a>01640     <span class="keywordflow">if</span> (h0 &gt; 0.8*maxh &amp;&amp; h0 &gt; hm &amp;&amp; h0 &gt; hp) {
<a name="l01641"></a>01641 
<a name="l01642"></a>01642       <span class="comment">/* quadratic interpolation */</span>
<a name="l01643"></a>01643       <span class="keywordtype">double</span> di = - 0.5 * (hp - hm) / (hp + hm - 2 * h0) ;
<a name="l01644"></a>01644       <span class="keywordtype">double</span> th = 2 * <a class="code" href="mathop_8h.html#19d43a5e0c355df553ebe825208a4cc1" title="Pi (math constant).">VL_PI</a> * (i + di + 0.5) / nbins ;
<a name="l01645"></a>01645       angles [ nangles++ ] = th ;
<a name="l01646"></a>01646       <span class="keywordflow">if</span>( nangles == 4 )
<a name="l01647"></a>01647         <span class="keywordflow">goto</span> enough_angles ;
<a name="l01648"></a>01648     }
<a name="l01649"></a>01649   }
<a name="l01650"></a>01650  enough_angles:
<a name="l01651"></a>01651   <span class="keywordflow">return</span> nangles ;
<a name="l01652"></a>01652 }
<a name="l01653"></a>01653 
<a name="l01654"></a>01654 
<a name="l01662"></a>01662 VL_INLINE <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>
<a name="l01663"></a>01663 <a class="code" href="sift_8c.html#b7319c742b088d2629f388b714baa996" title="Normalizes in norm L_2 a descriptor.">normalize_histogram</a>
<a name="l01664"></a><a class="code" href="sift_8c.html#b7319c742b088d2629f388b714baa996">01664</a> (<a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> *begin, <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> *end)
<a name="l01665"></a>01665 {
<a name="l01666"></a>01666   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>* iter ;
<a name="l01667"></a>01667   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>  norm = 0.0 ;
<a name="l01668"></a>01668 
<a name="l01669"></a>01669   <span class="keywordflow">for</span> (iter = begin ; iter != end ; ++ iter)
<a name="l01670"></a>01670     norm += (*iter) * (*iter) ;
<a name="l01671"></a>01671 
<a name="l01672"></a>01672   norm = <a class="code" href="mathop_8h.html#fd17414c0bd6edce9280378201a24847" title="Fast sqrt approximation.">vl_fast_sqrt_f</a> (norm) + <a class="code" href="mathop_8h.html#8088f3da04d6bce27544adaa6da948ca" title="IEEE single precision epsilon (math constant).">VL_EPSILON_F</a> ;
<a name="l01673"></a>01673 
<a name="l01674"></a>01674   <span class="keywordflow">for</span> (iter = begin; iter != end ; ++ iter)
<a name="l01675"></a>01675     *iter /= norm ;
<a name="l01676"></a>01676 
<a name="l01677"></a>01677   <span class="keywordflow">return</span> norm;
<a name="l01678"></a>01678 }
<a name="l01679"></a>01679 
<a name="l01712"></a>01712 VL_EXPORT
<a name="l01713"></a>01713 <span class="keywordtype">void</span>
<a name="l01714"></a><a class="code" href="sift_8h.html#3ddb5d720d7452b25aee72957ae17326">01714</a> <a class="code" href="sift_8c.html#3d537eb2a200c3c19e9a751178d1b9b5" title="Run the SIFT descriptor on raw data.">vl_sift_calc_raw_descriptor</a> (<a class="code" href="struct__VlSiftFilt.html" title="SIFT filter.">VlSiftFilt</a> <span class="keyword">const</span> *f,
<a name="l01715"></a>01715                              <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> <span class="keyword">const</span>* grad,
<a name="l01716"></a>01716                              <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> *descr,
<a name="l01717"></a>01717                              <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height,
<a name="l01718"></a>01718                              <span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y,
<a name="l01719"></a>01719                              <span class="keywordtype">double</span> sigma,
<a name="l01720"></a>01720                              <span class="keywordtype">double</span> angle0)
<a name="l01721"></a>01721 {
<a name="l01722"></a>01722   <span class="keywordtype">double</span> <span class="keyword">const</span> magnif = f-&gt; magnif ;
<a name="l01723"></a>01723 
<a name="l01724"></a>01724   <span class="keywordtype">int</span>          w      = width ;
<a name="l01725"></a>01725   <span class="keywordtype">int</span>          h      = height ;
<a name="l01726"></a>01726   <span class="keywordtype">int</span> <span class="keyword">const</span>    xo     = 2 ;         <span class="comment">/* x-stride */</span>
<a name="l01727"></a>01727   <span class="keywordtype">int</span> <span class="keyword">const</span>    yo     = 2 * w ;     <span class="comment">/* y-stride */</span>
<a name="l01728"></a>01728 
<a name="l01729"></a>01729   <span class="keywordtype">int</span>          xi     = (int) (x + 0.5) ;
<a name="l01730"></a>01730   <span class="keywordtype">int</span>          yi     = (int) (y + 0.5) ;
<a name="l01731"></a>01731 
<a name="l01732"></a>01732   <span class="keywordtype">double</span> <span class="keyword">const</span> st0    = sin (angle0) ;
<a name="l01733"></a>01733   <span class="keywordtype">double</span> <span class="keyword">const</span> ct0    = cos (angle0) ;
<a name="l01734"></a>01734   <span class="keywordtype">double</span> <span class="keyword">const</span> SBP    = magnif * sigma + <a class="code" href="mathop_8h.html#a2d957b08ce16011fc3827c270cd2664" title="IEEE double precision epsilon (math constant).">VL_EPSILON_D</a> ;
<a name="l01735"></a>01735   <span class="keywordtype">int</span>    <span class="keyword">const</span> W      = floor
<a name="l01736"></a>01736     (sqrt(2.0) * SBP * (NBP + 1) / 2.0 + 0.5) ;
<a name="l01737"></a>01737 
<a name="l01738"></a>01738   <span class="keywordtype">int</span> <span class="keyword">const</span> binto = 1 ;          <span class="comment">/* bin theta-stride */</span>
<a name="l01739"></a>01739   <span class="keywordtype">int</span> <span class="keyword">const</span> binyo = NBO * NBP ;  <span class="comment">/* bin y-stride */</span>
<a name="l01740"></a>01740   <span class="keywordtype">int</span> <span class="keyword">const</span> binxo = NBO ;        <span class="comment">/* bin x-stride */</span>
<a name="l01741"></a>01741 
<a name="l01742"></a>01742   <span class="keywordtype">int</span> bin, dxi, dyi ;
<a name="l01743"></a>01743   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> <span class="keyword">const</span> *pt ;
<a name="l01744"></a>01744   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>       *dpt ;
<a name="l01745"></a>01745 
<a name="l01746"></a>01746   <span class="comment">/* check bounds */</span>
<a name="l01747"></a>01747   <span class="keywordflow">if</span>(xi    &lt;  0               ||
<a name="l01748"></a>01748      xi    &gt;= w               ||
<a name="l01749"></a>01749      yi    &lt;  0               ||
<a name="l01750"></a>01750      yi    &gt;= h -    1        )
<a name="l01751"></a>01751     return ;
<a name="l01752"></a>01752 
<a name="l01753"></a>01753   <span class="comment">/* clear descriptor */</span>
<a name="l01754"></a>01754   memset (descr, 0, <span class="keyword">sizeof</span>(<a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>) * NBO*NBP*NBP) ;
<a name="l01755"></a>01755 
<a name="l01756"></a>01756   <span class="comment">/* Center the scale space and the descriptor on the current keypoint.</span>
<a name="l01757"></a>01757 <span class="comment">   * Note that dpt is pointing to the bin of center (SBP/2,SBP/2,0).</span>
<a name="l01758"></a>01758 <span class="comment">   */</span>
<a name="l01759"></a>01759   pt  = grad + xi*xo + yi*yo ;
<a name="l01760"></a>01760   dpt = descr + (NBP/2) * binyo + (NBP/2) * binxo ;
<a name="l01761"></a>01761 
<a name="l01762"></a>01762 <span class="preprocessor">#undef atd</span>
<a name="l01763"></a>01763 <span class="preprocessor"></span><span class="preprocessor">#define atd(dbinx,dbiny,dbint) *(dpt + (dbint)*binto + (dbiny)*binyo + (dbinx)*binxo)</span>
<a name="l01764"></a>01764 <span class="preprocessor"></span>
<a name="l01765"></a>01765   <span class="comment">/*</span>
<a name="l01766"></a>01766 <span class="comment">   * Process pixels in the intersection of the image rectangle</span>
<a name="l01767"></a>01767 <span class="comment">   * (1,1)-(M-1,N-1) and the keypoint bounding box.</span>
<a name="l01768"></a>01768 <span class="comment">   */</span>
<a name="l01769"></a>01769   <span class="keywordflow">for</span>(dyi =  <a class="code" href="generic_8h.html#c8a3f4020a3e381daadd4214668dc63c" title="Max operation.">VL_MAX</a>(- W,   - yi   ) ;
<a name="l01770"></a>01770       dyi &lt;= <a class="code" href="generic_8h.html#36f2f85796040ca2f71bb34a9f55969f" title="Min operation.">VL_MIN</a>(+ W, h - yi -1) ; ++ dyi) {
<a name="l01771"></a>01771 
<a name="l01772"></a>01772     <span class="keywordflow">for</span>(dxi =  <a class="code" href="generic_8h.html#c8a3f4020a3e381daadd4214668dc63c" title="Max operation.">VL_MAX</a>(- W,   - xi   ) ;
<a name="l01773"></a>01773         dxi &lt;= <a class="code" href="generic_8h.html#36f2f85796040ca2f71bb34a9f55969f" title="Min operation.">VL_MIN</a>(+ W, w - xi -1) ; ++ dxi) {
<a name="l01774"></a>01774 
<a name="l01775"></a>01775       <span class="comment">/* retrieve */</span>
<a name="l01776"></a>01776       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> mod   = *( pt + dxi*xo + dyi*yo + 0 ) ;
<a name="l01777"></a>01777       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> angle = *( pt + dxi*xo + dyi*yo + 1 ) ;
<a name="l01778"></a>01778       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> theta = <a class="code" href="mathop_8h.html#779371154b6f6c1a0f9bf51ad9afcd07" title="Fast mod(x, 2 * VL_PI).">vl_mod_2pi_f</a> (angle - angle0) ;
<a name="l01779"></a>01779 
<a name="l01780"></a>01780       <span class="comment">/* fractional displacement */</span>
<a name="l01781"></a>01781       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> dx = xi + dxi - x;
<a name="l01782"></a>01782       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> dy = yi + dyi - y;
<a name="l01783"></a>01783 
<a name="l01784"></a>01784       <span class="comment">/* get the displacement normalized w.r.t. the keypoint</span>
<a name="l01785"></a>01785 <span class="comment">         orientation and extension */</span>
<a name="l01786"></a>01786       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> nx = ( ct0 * dx + st0 * dy) / SBP ;
<a name="l01787"></a>01787       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> ny = (-st0 * dx + ct0 * dy) / SBP ;
<a name="l01788"></a>01788       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> nt = NBO * theta / (2 * <a class="code" href="mathop_8h.html#19d43a5e0c355df553ebe825208a4cc1" title="Pi (math constant).">VL_PI</a>) ;
<a name="l01789"></a>01789 
<a name="l01790"></a>01790       <span class="comment">/* Get the Gaussian weight of the sample. The Gaussian window</span>
<a name="l01791"></a>01791 <span class="comment">       * has a standard deviation equal to NBP/2. Note that dx and dy</span>
<a name="l01792"></a>01792 <span class="comment">       * are in the normalized frame, so that -NBP/2 &lt;= dx &lt;=</span>
<a name="l01793"></a>01793 <span class="comment">       * NBP/2. */</span>
<a name="l01794"></a>01794       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> <span class="keyword">const</span> wsigma = f-&gt;<a class="code" href="struct__VlSiftFilt.html#5540e0aab7df5e5abfb58d3d07af844b">windowSize</a> ;
<a name="l01795"></a>01795       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> win = <a class="code" href="sift_8c.html#54a28f7f095a58401a7917073f43866f" title="Fast  approximation.">fast_expn</a>
<a name="l01796"></a>01796         ((nx*nx + ny*ny)/(2.0 * wsigma * wsigma)) ;
<a name="l01797"></a>01797 
<a name="l01798"></a>01798       <span class="comment">/* The sample will be distributed in 8 adjacent bins.</span>
<a name="l01799"></a>01799 <span class="comment">         We start from the ``lower-left'' bin. */</span>
<a name="l01800"></a>01800       <span class="keywordtype">int</span>         binx = <a class="code" href="mathop_8h.html#0a641bb83f3aa7db107a51f63a534b52" title="Fast (int) floor(x).">vl_floor_f</a> (nx - 0.5) ;
<a name="l01801"></a>01801       <span class="keywordtype">int</span>         biny = <a class="code" href="mathop_8h.html#0a641bb83f3aa7db107a51f63a534b52" title="Fast (int) floor(x).">vl_floor_f</a> (ny - 0.5) ;
<a name="l01802"></a>01802       <span class="keywordtype">int</span>         bint = <a class="code" href="mathop_8h.html#0a641bb83f3aa7db107a51f63a534b52" title="Fast (int) floor(x).">vl_floor_f</a> (nt) ;
<a name="l01803"></a>01803       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> rbinx = nx - (binx + 0.5) ;
<a name="l01804"></a>01804       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> rbiny = ny - (biny + 0.5) ;
<a name="l01805"></a>01805       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> rbint = nt - bint ;
<a name="l01806"></a>01806       <span class="keywordtype">int</span>         dbinx ;
<a name="l01807"></a>01807       <span class="keywordtype">int</span>         dbiny ;
<a name="l01808"></a>01808       <span class="keywordtype">int</span>         dbint ;
<a name="l01809"></a>01809 
<a name="l01810"></a>01810       <span class="comment">/* Distribute the current sample into the 8 adjacent bins*/</span>
<a name="l01811"></a>01811       <span class="keywordflow">for</span>(dbinx = 0 ; dbinx &lt; 2 ; ++dbinx) {
<a name="l01812"></a>01812         <span class="keywordflow">for</span>(dbiny = 0 ; dbiny &lt; 2 ; ++dbiny) {
<a name="l01813"></a>01813           <span class="keywordflow">for</span>(dbint = 0 ; dbint &lt; 2 ; ++dbint) {
<a name="l01814"></a>01814 
<a name="l01815"></a>01815             <span class="keywordflow">if</span> (binx + dbinx &gt;= - (NBP/2) &amp;&amp;
<a name="l01816"></a>01816                 binx + dbinx &lt;    (NBP/2) &amp;&amp;
<a name="l01817"></a>01817                 biny + dbiny &gt;= - (NBP/2) &amp;&amp;
<a name="l01818"></a>01818                 biny + dbiny &lt;    (NBP/2) ) {
<a name="l01819"></a>01819               <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> weight = win
<a name="l01820"></a>01820                 * mod
<a name="l01821"></a>01821                 * <a class="code" href="mathop_8h.html#c661df89e4bbb2730b3b5a8d15713084" title="Fast abs(x).">vl_abs_f</a> (1 - dbinx - rbinx)
<a name="l01822"></a>01822                 * <a class="code" href="mathop_8h.html#c661df89e4bbb2730b3b5a8d15713084" title="Fast abs(x).">vl_abs_f</a> (1 - dbiny - rbiny)
<a name="l01823"></a>01823                 * <a class="code" href="mathop_8h.html#c661df89e4bbb2730b3b5a8d15713084" title="Fast abs(x).">vl_abs_f</a> (1 - dbint - rbint) ;
<a name="l01824"></a>01824 
<a name="l01825"></a>01825               atd(binx+dbinx, biny+dbiny, (bint+dbint) % NBO) += weight ;
<a name="l01826"></a>01826             }
<a name="l01827"></a>01827           }
<a name="l01828"></a>01828         }
<a name="l01829"></a>01829       }
<a name="l01830"></a>01830     }
<a name="l01831"></a>01831   }
<a name="l01832"></a>01832 
<a name="l01833"></a>01833   <span class="comment">/* Standard SIFT descriptors are normalized, truncated and normalized again */</span>
<a name="l01834"></a>01834   <span class="keywordflow">if</span>(1) {
<a name="l01835"></a>01835 
<a name="l01836"></a>01836     <span class="comment">/* normalize L2 norm */</span>
<a name="l01837"></a>01837     <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> norm = <a class="code" href="sift_8c.html#b7319c742b088d2629f388b714baa996" title="Normalizes in norm L_2 a descriptor.">normalize_histogram</a> (descr, descr + NBO*NBP*NBP) ;
<a name="l01838"></a>01838 
<a name="l01839"></a>01839     <span class="comment">/*</span>
<a name="l01840"></a>01840 <span class="comment">       Set the descriptor to zero if it is lower than our</span>
<a name="l01841"></a>01841 <span class="comment">       norm_threshold.  We divide by the number of samples in the</span>
<a name="l01842"></a>01842 <span class="comment">       descriptor region becasue the Gaussian window used in the</span>
<a name="l01843"></a>01843 <span class="comment">       calculation fo the descriptor is not normalized.</span>
<a name="l01844"></a>01844 <span class="comment">     */</span>
<a name="l01845"></a>01845     <span class="keywordtype">int</span> numSamples =
<a name="l01846"></a>01846       (<a class="code" href="generic_8h.html#36f2f85796040ca2f71bb34a9f55969f" title="Min operation.">VL_MIN</a>(W, w - xi -1) - <a class="code" href="generic_8h.html#c8a3f4020a3e381daadd4214668dc63c" title="Max operation.">VL_MAX</a>(-W, - xi) + 1) *
<a name="l01847"></a>01847       (<a class="code" href="generic_8h.html#36f2f85796040ca2f71bb34a9f55969f" title="Min operation.">VL_MIN</a>(W, h - yi -1) - <a class="code" href="generic_8h.html#c8a3f4020a3e381daadd4214668dc63c" title="Max operation.">VL_MAX</a>(-W, - yi) + 1) ;
<a name="l01848"></a>01848 
<a name="l01849"></a>01849     <span class="keywordflow">if</span>(f-&gt; norm_thresh &amp;&amp; norm &lt; f-&gt; norm_thresh * numSamples) {
<a name="l01850"></a>01850         <span class="keywordflow">for</span>(bin = 0; bin &lt; NBO*NBP*NBP ; ++ bin)
<a name="l01851"></a>01851             descr [bin] = 0;
<a name="l01852"></a>01852     }
<a name="l01853"></a>01853     <span class="keywordflow">else</span> {
<a name="l01854"></a>01854       <span class="comment">/* truncate at 0.2. */</span>
<a name="l01855"></a>01855       <span class="keywordflow">for</span>(bin = 0; bin &lt; NBO*NBP*NBP ; ++ bin) {
<a name="l01856"></a>01856         <span class="keywordflow">if</span> (descr [bin] &gt; 0.2) descr [bin] = 0.2;
<a name="l01857"></a>01857       }
<a name="l01858"></a>01858 
<a name="l01859"></a>01859       <span class="comment">/* normalize again. */</span>
<a name="l01860"></a>01860       <a class="code" href="sift_8c.html#b7319c742b088d2629f388b714baa996" title="Normalizes in norm L_2 a descriptor.">normalize_histogram</a> (descr, descr + NBO*NBP*NBP) ;
<a name="l01861"></a>01861     }
<a name="l01862"></a>01862   }
<a name="l01863"></a>01863 }
<a name="l01864"></a>01864 
<a name="l01881"></a>01881 VL_EXPORT
<a name="l01882"></a>01882 <span class="keywordtype">void</span>
<a name="l01883"></a><a class="code" href="sift_8h.html#8631e63443c1faa7069a4e8e885fd82d">01883</a> <a class="code" href="sift_8c.html#d5021ed313da8e8c2d0174f711df6b0e" title="Compute the descriptor of a keypoint.">vl_sift_calc_keypoint_descriptor</a> (<a class="code" href="struct__VlSiftFilt.html" title="SIFT filter.">VlSiftFilt</a> *f,
<a name="l01884"></a>01884                                   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> *descr,
<a name="l01885"></a>01885                                   <a class="code" href="struct__VlSiftKeypoint.html" title="SIFT filter keypoint.">VlSiftKeypoint</a> <span class="keyword">const</span>* k,
<a name="l01886"></a>01886                                   <span class="keywordtype">double</span> angle0)
<a name="l01887"></a>01887 {
<a name="l01888"></a>01888   <span class="comment">/*</span>
<a name="l01889"></a>01889 <span class="comment">     The SIFT descriptor is a three dimensional histogram of the</span>
<a name="l01890"></a>01890 <span class="comment">     position and orientation of the gradient.  There are NBP bins for</span>
<a name="l01891"></a>01891 <span class="comment">     each spatial dimension and NBO bins for the orientation dimension,</span>
<a name="l01892"></a>01892 <span class="comment">     for a total of NBP x NBP x NBO bins.</span>
<a name="l01893"></a>01893 <span class="comment"></span>
<a name="l01894"></a>01894 <span class="comment">     The support of each spatial bin has an extension of SBP = 3sigma</span>
<a name="l01895"></a>01895 <span class="comment">     pixels, where sigma is the scale of the keypoint.  Thus all the</span>
<a name="l01896"></a>01896 <span class="comment">     bins together have a support SBP x NBP pixels wide. Since</span>
<a name="l01897"></a>01897 <span class="comment">     weighting and interpolation of pixel is used, the support extends</span>
<a name="l01898"></a>01898 <span class="comment">     by another half bin. Therefore, the support is a square window of</span>
<a name="l01899"></a>01899 <span class="comment">     SBP x (NBP + 1) pixels. Finally, since the patch can be</span>
<a name="l01900"></a>01900 <span class="comment">     arbitrarily rotated, we need to consider a window 2W += sqrt(2) x</span>
<a name="l01901"></a>01901 <span class="comment">     SBP x (NBP + 1) pixels wide.</span>
<a name="l01902"></a>01902 <span class="comment">  */</span>
<a name="l01903"></a>01903 
<a name="l01904"></a>01904   <span class="keywordtype">double</span> <span class="keyword">const</span> magnif      = f-&gt; magnif ;
<a name="l01905"></a>01905 
<a name="l01906"></a>01906   <span class="keywordtype">double</span>       xper        = pow (2.0, f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a>) ;
<a name="l01907"></a>01907 
<a name="l01908"></a>01908   <span class="keywordtype">int</span>          w           = f-&gt; octave_width ;
<a name="l01909"></a>01909   <span class="keywordtype">int</span>          h           = f-&gt; octave_height ;
<a name="l01910"></a>01910   <span class="keywordtype">int</span> <span class="keyword">const</span>    xo          = 2 ;         <span class="comment">/* x-stride */</span>
<a name="l01911"></a>01911   <span class="keywordtype">int</span> <span class="keyword">const</span>    yo          = 2 * w ;     <span class="comment">/* y-stride */</span>
<a name="l01912"></a>01912   <span class="keywordtype">int</span> <span class="keyword">const</span>    so          = 2 * w * h ; <span class="comment">/* s-stride */</span>
<a name="l01913"></a>01913   <span class="keywordtype">double</span>       x           = k-&gt; x     / xper ;
<a name="l01914"></a>01914   <span class="keywordtype">double</span>       y           = k-&gt; y     / xper ;
<a name="l01915"></a>01915   <span class="keywordtype">double</span>       sigma       = k-&gt; sigma / xper ;
<a name="l01916"></a>01916 
<a name="l01917"></a>01917   <span class="keywordtype">int</span>          xi          = (int) (x + 0.5) ;
<a name="l01918"></a>01918   <span class="keywordtype">int</span>          yi          = (int) (y + 0.5) ;
<a name="l01919"></a>01919   <span class="keywordtype">int</span>          si          = k-&gt; is ;
<a name="l01920"></a>01920 
<a name="l01921"></a>01921   <span class="keywordtype">double</span> <span class="keyword">const</span> st0         = sin (angle0) ;
<a name="l01922"></a>01922   <span class="keywordtype">double</span> <span class="keyword">const</span> ct0         = cos (angle0) ;
<a name="l01923"></a>01923   <span class="keywordtype">double</span> <span class="keyword">const</span> SBP         = magnif * sigma ;
<a name="l01924"></a>01924   <span class="keywordtype">int</span>    <span class="keyword">const</span> W           = floor
<a name="l01925"></a>01925     (sqrt(2.0) * SBP * (NBP + 1) / 2.0 + 0.5) ;
<a name="l01926"></a>01926 
<a name="l01927"></a>01927   <span class="keywordtype">int</span> <span class="keyword">const</span> binto = 1 ;          <span class="comment">/* bin theta-stride */</span>
<a name="l01928"></a>01928   <span class="keywordtype">int</span> <span class="keyword">const</span> binyo = NBO * NBP ;  <span class="comment">/* bin y-stride */</span>
<a name="l01929"></a>01929   <span class="keywordtype">int</span> <span class="keyword">const</span> binxo = NBO ;        <span class="comment">/* bin x-stride */</span>
<a name="l01930"></a>01930 
<a name="l01931"></a>01931   <span class="keywordtype">int</span> bin, dxi, dyi ;
<a name="l01932"></a>01932   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> <span class="keyword">const</span> *pt ;
<a name="l01933"></a>01933   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>       *dpt ;
<a name="l01934"></a>01934 
<a name="l01935"></a>01935   <span class="comment">/* check bounds */</span>
<a name="l01936"></a>01936   <span class="keywordflow">if</span>(k-&gt;<a class="code" href="struct__VlSiftKeypoint.html#c50bd6df4c02dc9a8328182138bdfd96">o</a>  != f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a>        ||
<a name="l01937"></a>01937      xi    &lt;  0               ||
<a name="l01938"></a>01938      xi    &gt;= w               ||
<a name="l01939"></a>01939      yi    &lt;  0               ||
<a name="l01940"></a>01940      yi    &gt;= h -    1        ||
<a name="l01941"></a>01941      si    &lt;  f-&gt;s_min + 1    ||
<a name="l01942"></a>01942      si    &gt;  f-&gt;<a class="code" href="struct__VlSiftFilt.html#51a63e5aa77dca58de4c025ff40f77ab">s_max</a> - 2     )
<a name="l01943"></a>01943     return ;
<a name="l01944"></a>01944 
<a name="l01945"></a>01945   <span class="comment">/* synchronize gradient buffer */</span>
<a name="l01946"></a>01946   <a class="code" href="sift_8c.html#ce1fba61b0cc6ad7b1b0f9a07eabdf87" title="Update gradients to current GSS octave.">update_gradient</a> (f) ;
<a name="l01947"></a>01947 
<a name="l01948"></a>01948   <span class="comment">/* VL_PRINTF("W = %d ; magnif = %g ; SBP = %g\n", W,magnif,SBP) ; */</span>
<a name="l01949"></a>01949 
<a name="l01950"></a>01950   <span class="comment">/* clear descriptor */</span>
<a name="l01951"></a>01951   memset (descr, 0, <span class="keyword">sizeof</span>(<a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>) * NBO*NBP*NBP) ;
<a name="l01952"></a>01952 
<a name="l01953"></a>01953   <span class="comment">/* Center the scale space and the descriptor on the current keypoint.</span>
<a name="l01954"></a>01954 <span class="comment">   * Note that dpt is pointing to the bin of center (SBP/2,SBP/2,0).</span>
<a name="l01955"></a>01955 <span class="comment">   */</span>
<a name="l01956"></a>01956   pt  = f-&gt;<a class="code" href="struct__VlSiftFilt.html#3dc6a5613163485ab9f0607b662af868">grad</a> + xi*xo + yi*yo + (si - f-&gt;<a class="code" href="struct__VlSiftFilt.html#3631bdd696add103f8ebfe76750e9228">s_min</a> - 1)*so ;
<a name="l01957"></a>01957   dpt = descr + (NBP/2) * binyo + (NBP/2) * binxo ;
<a name="l01958"></a>01958 
<a name="l01959"></a>01959 <span class="preprocessor">#undef atd</span>
<a name="l01960"></a>01960 <span class="preprocessor"></span><span class="preprocessor">#define atd(dbinx,dbiny,dbint) *(dpt + (dbint)*binto + (dbiny)*binyo + (dbinx)*binxo)</span>
<a name="l01961"></a>01961 <span class="preprocessor"></span>
<a name="l01962"></a>01962   <span class="comment">/*</span>
<a name="l01963"></a>01963 <span class="comment">   * Process pixels in the intersection of the image rectangle</span>
<a name="l01964"></a>01964 <span class="comment">   * (1,1)-(M-1,N-1) and the keypoint bounding box.</span>
<a name="l01965"></a>01965 <span class="comment">   */</span>
<a name="l01966"></a>01966   <span class="keywordflow">for</span>(dyi =  <a class="code" href="generic_8h.html#c8a3f4020a3e381daadd4214668dc63c" title="Max operation.">VL_MAX</a> (- W, 1 - yi    ) ;
<a name="l01967"></a>01967       dyi &lt;= <a class="code" href="generic_8h.html#36f2f85796040ca2f71bb34a9f55969f" title="Min operation.">VL_MIN</a> (+ W, h - yi - 2) ; ++ dyi) {
<a name="l01968"></a>01968 
<a name="l01969"></a>01969     <span class="keywordflow">for</span>(dxi =  <a class="code" href="generic_8h.html#c8a3f4020a3e381daadd4214668dc63c" title="Max operation.">VL_MAX</a> (- W, 1 - xi    ) ;
<a name="l01970"></a>01970         dxi &lt;= <a class="code" href="generic_8h.html#36f2f85796040ca2f71bb34a9f55969f" title="Min operation.">VL_MIN</a> (+ W, w - xi - 2) ; ++ dxi) {
<a name="l01971"></a>01971 
<a name="l01972"></a>01972       <span class="comment">/* retrieve */</span>
<a name="l01973"></a>01973       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> mod   = *( pt + dxi*xo + dyi*yo + 0 ) ;
<a name="l01974"></a>01974       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> angle = *( pt + dxi*xo + dyi*yo + 1 ) ;
<a name="l01975"></a>01975       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> theta = <a class="code" href="mathop_8h.html#779371154b6f6c1a0f9bf51ad9afcd07" title="Fast mod(x, 2 * VL_PI).">vl_mod_2pi_f</a> (angle - angle0) ;
<a name="l01976"></a>01976 
<a name="l01977"></a>01977       <span class="comment">/* fractional displacement */</span>
<a name="l01978"></a>01978       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> dx = xi + dxi - x;
<a name="l01979"></a>01979       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> dy = yi + dyi - y;
<a name="l01980"></a>01980 
<a name="l01981"></a>01981       <span class="comment">/* get the displacement normalized w.r.t. the keypoint</span>
<a name="l01982"></a>01982 <span class="comment">         orientation and extension */</span>
<a name="l01983"></a>01983       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> nx = ( ct0 * dx + st0 * dy) / SBP ;
<a name="l01984"></a>01984       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> ny = (-st0 * dx + ct0 * dy) / SBP ;
<a name="l01985"></a>01985       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> nt = NBO * theta / (2 * <a class="code" href="mathop_8h.html#19d43a5e0c355df553ebe825208a4cc1" title="Pi (math constant).">VL_PI</a>) ;
<a name="l01986"></a>01986 
<a name="l01987"></a>01987       <span class="comment">/* Get the Gaussian weight of the sample. The Gaussian window</span>
<a name="l01988"></a>01988 <span class="comment">       * has a standard deviation equal to NBP/2. Note that dx and dy</span>
<a name="l01989"></a>01989 <span class="comment">       * are in the normalized frame, so that -NBP/2 &lt;= dx &lt;=</span>
<a name="l01990"></a>01990 <span class="comment">       * NBP/2. */</span>
<a name="l01991"></a>01991       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> <span class="keyword">const</span> wsigma = f-&gt;<a class="code" href="struct__VlSiftFilt.html#5540e0aab7df5e5abfb58d3d07af844b">windowSize</a> ;
<a name="l01992"></a>01992       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> win = <a class="code" href="sift_8c.html#54a28f7f095a58401a7917073f43866f" title="Fast  approximation.">fast_expn</a>
<a name="l01993"></a>01993         ((nx*nx + ny*ny)/(2.0 * wsigma * wsigma)) ;
<a name="l01994"></a>01994 
<a name="l01995"></a>01995       <span class="comment">/* The sample will be distributed in 8 adjacent bins.</span>
<a name="l01996"></a>01996 <span class="comment">         We start from the ``lower-left'' bin. */</span>
<a name="l01997"></a>01997       <span class="keywordtype">int</span>         binx = <a class="code" href="mathop_8h.html#0a641bb83f3aa7db107a51f63a534b52" title="Fast (int) floor(x).">vl_floor_f</a> (nx - 0.5) ;
<a name="l01998"></a>01998       <span class="keywordtype">int</span>         biny = <a class="code" href="mathop_8h.html#0a641bb83f3aa7db107a51f63a534b52" title="Fast (int) floor(x).">vl_floor_f</a> (ny - 0.5) ;
<a name="l01999"></a>01999       <span class="keywordtype">int</span>         bint = <a class="code" href="mathop_8h.html#0a641bb83f3aa7db107a51f63a534b52" title="Fast (int) floor(x).">vl_floor_f</a> (nt) ;
<a name="l02000"></a>02000       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> rbinx = nx - (binx + 0.5) ;
<a name="l02001"></a>02001       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> rbiny = ny - (biny + 0.5) ;
<a name="l02002"></a>02002       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> rbint = nt - bint ;
<a name="l02003"></a>02003       <span class="keywordtype">int</span>         dbinx ;
<a name="l02004"></a>02004       <span class="keywordtype">int</span>         dbiny ;
<a name="l02005"></a>02005       <span class="keywordtype">int</span>         dbint ;
<a name="l02006"></a>02006 
<a name="l02007"></a>02007       <span class="comment">/* Distribute the current sample into the 8 adjacent bins*/</span>
<a name="l02008"></a>02008       <span class="keywordflow">for</span>(dbinx = 0 ; dbinx &lt; 2 ; ++dbinx) {
<a name="l02009"></a>02009         <span class="keywordflow">for</span>(dbiny = 0 ; dbiny &lt; 2 ; ++dbiny) {
<a name="l02010"></a>02010           <span class="keywordflow">for</span>(dbint = 0 ; dbint &lt; 2 ; ++dbint) {
<a name="l02011"></a>02011 
<a name="l02012"></a>02012             <span class="keywordflow">if</span> (binx + dbinx &gt;= - (NBP/2) &amp;&amp;
<a name="l02013"></a>02013                 binx + dbinx &lt;    (NBP/2) &amp;&amp;
<a name="l02014"></a>02014                 biny + dbiny &gt;= - (NBP/2) &amp;&amp;
<a name="l02015"></a>02015                 biny + dbiny &lt;    (NBP/2) ) {
<a name="l02016"></a>02016               <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> weight = win
<a name="l02017"></a>02017                 * mod
<a name="l02018"></a>02018                 * <a class="code" href="mathop_8h.html#c661df89e4bbb2730b3b5a8d15713084" title="Fast abs(x).">vl_abs_f</a> (1 - dbinx - rbinx)
<a name="l02019"></a>02019                 * <a class="code" href="mathop_8h.html#c661df89e4bbb2730b3b5a8d15713084" title="Fast abs(x).">vl_abs_f</a> (1 - dbiny - rbiny)
<a name="l02020"></a>02020                 * <a class="code" href="mathop_8h.html#c661df89e4bbb2730b3b5a8d15713084" title="Fast abs(x).">vl_abs_f</a> (1 - dbint - rbint) ;
<a name="l02021"></a>02021 
<a name="l02022"></a>02022               atd(binx+dbinx, biny+dbiny, (bint+dbint) % NBO) += weight ;
<a name="l02023"></a>02023             }
<a name="l02024"></a>02024           }
<a name="l02025"></a>02025         }
<a name="l02026"></a>02026       }
<a name="l02027"></a>02027     }
<a name="l02028"></a>02028   }
<a name="l02029"></a>02029 
<a name="l02030"></a>02030   <span class="comment">/* Standard SIFT descriptors are normalized, truncated and normalized again */</span>
<a name="l02031"></a>02031   <span class="keywordflow">if</span>(1) {
<a name="l02032"></a>02032 
<a name="l02033"></a>02033     <span class="comment">/* Normalize the histogram to L2 unit length. */</span>
<a name="l02034"></a>02034     <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> norm = <a class="code" href="sift_8c.html#b7319c742b088d2629f388b714baa996" title="Normalizes in norm L_2 a descriptor.">normalize_histogram</a> (descr, descr + NBO*NBP*NBP) ;
<a name="l02035"></a>02035 
<a name="l02036"></a>02036     <span class="comment">/* Set the descriptor to zero if it is lower than our norm_threshold */</span>
<a name="l02037"></a>02037     <span class="keywordflow">if</span>(f-&gt; norm_thresh &amp;&amp; norm &lt; f-&gt; norm_thresh) {
<a name="l02038"></a>02038         <span class="keywordflow">for</span>(bin = 0; bin &lt; NBO*NBP*NBP ; ++ bin)
<a name="l02039"></a>02039             descr [bin] = 0;
<a name="l02040"></a>02040     }
<a name="l02041"></a>02041     <span class="keywordflow">else</span> {
<a name="l02042"></a>02042 
<a name="l02043"></a>02043       <span class="comment">/* Truncate at 0.2. */</span>
<a name="l02044"></a>02044       <span class="keywordflow">for</span>(bin = 0; bin &lt; NBO*NBP*NBP ; ++ bin) {
<a name="l02045"></a>02045         <span class="keywordflow">if</span> (descr [bin] &gt; 0.2) descr [bin] = 0.2;
<a name="l02046"></a>02046       }
<a name="l02047"></a>02047 
<a name="l02048"></a>02048       <span class="comment">/* Normalize again. */</span>
<a name="l02049"></a>02049       <a class="code" href="sift_8c.html#b7319c742b088d2629f388b714baa996" title="Normalizes in norm L_2 a descriptor.">normalize_histogram</a> (descr, descr + NBO*NBP*NBP) ;
<a name="l02050"></a>02050     }
<a name="l02051"></a>02051   }
<a name="l02052"></a>02052 
<a name="l02053"></a>02053 }
<a name="l02054"></a>02054 
<a name="l02121"></a>02121 VL_EXPORT
<a name="l02122"></a>02122 <span class="keywordtype">void</span>
<a name="l02123"></a><a class="code" href="sift_8h.html#445bbb5bcedabfa3c16df83d1817cd8d">02123</a> <a class="code" href="sift_8c.html#445bbb5bcedabfa3c16df83d1817cd8d" title="Initialize a keypoint from its position and scale.">vl_sift_keypoint_init</a> (<a class="code" href="struct__VlSiftFilt.html" title="SIFT filter.">VlSiftFilt</a> <span class="keyword">const</span> *f,
<a name="l02124"></a>02124                        <a class="code" href="struct__VlSiftKeypoint.html" title="SIFT filter keypoint.">VlSiftKeypoint</a> *k,
<a name="l02125"></a>02125                        <span class="keywordtype">double</span> x,
<a name="l02126"></a>02126                        <span class="keywordtype">double</span> y,
<a name="l02127"></a>02127                        <span class="keywordtype">double</span> sigma)
<a name="l02128"></a>02128 {
<a name="l02129"></a>02129   <span class="keywordtype">int</span>    o, ix, iy, is ;
<a name="l02130"></a>02130   <span class="keywordtype">double</span> s, phi, xper ;
<a name="l02131"></a>02131 
<a name="l02132"></a>02132   phi = log2 (sigma / f-&gt;<a class="code" href="struct__VlSiftFilt.html#26c296dd10f53b29b32e40d73294bfc9">sigma0</a>) ;
<a name="l02133"></a>02133   o   = <a class="code" href="mathop_8h.html#48bb7ee0a0b8f26c1ddcc8e9821f36ac" title="Fast (int) floor(x).">vl_floor_d</a> (phi -  ((<span class="keywordtype">double</span>) f-&gt;<a class="code" href="struct__VlSiftFilt.html#3631bdd696add103f8ebfe76750e9228">s_min</a> + 0.5) / f-&gt;<a class="code" href="struct__VlSiftFilt.html#8531fa640678ec497e74d8fe4bfd18bd">S</a>) ;
<a name="l02134"></a>02134   o   = <a class="code" href="generic_8h.html#36f2f85796040ca2f71bb34a9f55969f" title="Min operation.">VL_MIN</a> (o, f-&gt;<a class="code" href="struct__VlSiftFilt.html#9abcca743ed9482df03ccd9703909378">o_min</a> + f-&gt;<a class="code" href="struct__VlSiftFilt.html#e36d5a3c012a53484bbf7ef1a125e69e">O</a> - 1) ;
<a name="l02135"></a>02135   o   = <a class="code" href="generic_8h.html#c8a3f4020a3e381daadd4214668dc63c" title="Max operation.">VL_MAX</a> (o, f-&gt;<a class="code" href="struct__VlSiftFilt.html#9abcca743ed9482df03ccd9703909378">o_min</a>           ) ;
<a name="l02136"></a>02136   s   = f-&gt;<a class="code" href="struct__VlSiftFilt.html#8531fa640678ec497e74d8fe4bfd18bd">S</a> * (phi - o) ;
<a name="l02137"></a>02137 
<a name="l02138"></a>02138   is  = (int)(s + 0.5) ;
<a name="l02139"></a>02139   is  = <a class="code" href="generic_8h.html#36f2f85796040ca2f71bb34a9f55969f" title="Min operation.">VL_MIN</a>(is, f-&gt;<a class="code" href="struct__VlSiftFilt.html#51a63e5aa77dca58de4c025ff40f77ab">s_max</a> - 2) ;
<a name="l02140"></a>02140   is  = <a class="code" href="generic_8h.html#c8a3f4020a3e381daadd4214668dc63c" title="Max operation.">VL_MAX</a>(is, f-&gt;<a class="code" href="struct__VlSiftFilt.html#3631bdd696add103f8ebfe76750e9228">s_min</a> + 1) ;
<a name="l02141"></a>02141 
<a name="l02142"></a>02142   xper = pow (2.0, o) ;
<a name="l02143"></a>02143   ix   = (int)(x / xper + 0.5) ;
<a name="l02144"></a>02144   iy   = (int)(y / xper + 0.5) ;
<a name="l02145"></a>02145 
<a name="l02146"></a>02146   k -&gt; o  = o ;
<a name="l02147"></a>02147 
<a name="l02148"></a>02148   k -&gt; ix = ix ;
<a name="l02149"></a>02149   k -&gt; iy = iy ;
<a name="l02150"></a>02150   k -&gt; is = is ;
<a name="l02151"></a>02151 
<a name="l02152"></a>02152   k -&gt; x = x ;
<a name="l02153"></a>02153   k -&gt; y = y ;
<a name="l02154"></a>02154   k -&gt; s = s ;
<a name="l02155"></a>02155 
<a name="l02156"></a>02156   k-&gt;<a class="code" href="struct__VlSiftKeypoint.html#9a19aaa4aae25c5d94fd275df6ecdb7c">sigma</a> = sigma ;
<a name="l02157"></a>02157 }
</pre></div></div>
     <!-- Doc Here -->
    </div>
   
   </div>
   <div class="clear">&nbsp;</div>
  </div> <!-- pagebody -->
  <div id="footer">
   &copy; 2005-09 Andrea Vedaldi and Brian Fulkerson
  </div> <!-- footer -->
  
  <!-- Google Analytics Begins -->
  <script xml:space="preserve" type="text/javascript">
   //<![CDATA[
    var localre = /vlfeat.org/;
    if(document.location.host.search(localre) != -1)
    {
   var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
   document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
   }
   //]]>
  </script>
  <script xml:space="preserve" type="text/javascript">
    //<![CDATA[
    var localre = /vlfeat.org/;
    if(document.location.host.search(localre) != -1)
    {

   try {
   var pageTracker = _gat._getTracker("UA-4936091-2");
   pageTracker._trackPageview();
   } catch(err) {}

   }
   //]]>
  </script>
  <!-- Google Analytics Ends -->
 </body>
</html>

 
